[
    {
        "problem_number": "1",
        "question": "Ben Bitdiddle is learning to code, and he has decided to build a website! To authenticate users, he created a database with all of his users' usernames and the SHA-256 hash of their passwords. Unfortunately for him, Eve has stolen the contents of this database.\n\nIn this problem, we will explore some of the space/time tradeoffs which Eve can use to invert cryptographic hashes of passwords. Suppose Eve knows that all the passwords come from a set \\(S\\), and our hash function produces \\(d\\)-bit strings. With no precomputation, if \\(|S|\\) is much smaller than \\(2^{d}\\), then inverting the hash of a password will take Eve about \\(|S|/2\\) tries in expectation, and therefore time that is \\(\\Omega(|S|)\\).\n\nIf Eve had infinite time to prepare for breaking the password hashes, she could construct a lookup table with the hash of every possible password in it. Inverting a password hash would just be an \\(O(1)\\) table lookup, but Eve would then be required to store a table of size \\(\\Omega(|S|)\\).",
        "subquestions": [
            {
                "problem_number": "1a",
                "question": "One early approach to achieving a finer-grained tradeoff between table size and lookup time is hash chains. Just as our cryptographic hash function \\(h\\) is a pseudorandom function mapping \\(S\\) to \\(\\{0,1\\}^{d}\\), it is typically possible to construct a pseudorandom function \\(f\\) mapping \\(\\{0,1\\}^{d}\\) to \\(S\\). In particular, this is possible if \\(S\\) is _efficiently enumerable_. This means that there is an ordering on \\(S\\) such that the \\(i\\)th element of \\(S\\) can be efficiently computed.\n\nIf \\(S\\) is the set of all 10 character alphanumeric passwords, construct a pseudorandom function mapping \\(\\{0,1\\}^{256}\\) to \\(S\\).",
                "answer": "We desire a pseudorandom mapping from \\(\\{0,1\\}^{256}\\) to \\(S\\). First, we note that \\(S\\) is efficiently enumerable. In particular, \\(S\\) follows standard lexicographic order, where each of the 62 possible characters follows the ordering \\(0...9 \\leftarrow A-Z \\leftarrow a-z\\). Then, of the \\(62^{10}\\) possible values in \\(S\\), the \\(i\\)th value is easily attainable by computing the base 62 representation of \\(i-1\\). Now, we want a pseudorandom reduction function, \\(R\\), which maps \\(2^{256}\\) possible values to \\(62^{10}\\). One possible function is simply \\(R(hv) = \\text{sha256}(hv) \\mod 62^{10}\\). In other words, we use a hash function on the item from \\(\\{0,1\\}^{256}\\) to map to another item from \\(\\{0,1\\}^{256}\\) and then take the value mod \\(62^{10}\\). This function is very nearly uniform, since \\(\\frac{2^{256}}{62^{10}} \\geq 10^{59}\\), assuming the hash function is sufficiently random."
            },
            {
                "problem_number": "1b",
                "question": "The next idea is that \\(f\\) and \\(h\\) are alternately applied \\(k\\) times on a random password to yield a chain of \\(k\\) passwords and password hashes. Show that if we store a single entry in a lookup table mapping the last hash of this chain to the starting password, then in \\(O(k)\\) time, we can invert any of the hashes which occurred in the chain.",
                "answer": "The general idea is that given some hash \\(hv\\), we can run it through a similar chain process \\(k\\) times. If any of the intermediate hashes match the last hash of some chain in the table, we obtain the corresponding start of the chain \\(s\\). We start with \\(s\\), and walk through the chain again, until we reach some segment \\(\\text{hash}(pl) = hv\\), where \\(pl\\) is our desired plain text. Given that each iteration of hashing or reducing takes \\(O(1)\\) time, and that lookup takes \\(O(1)\\) time, we have an \\(O(k)\\) algorithm for inverting any hash that occurs in some chain."
            },
            {
                "problem_number": "1c",
                "question": "A natural next idea is to store multiple (hash, password) pairs in the lookup table, all constructed in the same way. Show that if all the corresponding chains are of length \\(k\\), then we can efficiently invert the hash of any password which occurs in any of the chains. If you create \\(|S|/k\\) chains of length \\(k\\) as described above, do you expect the chains to contain close to \\(|S|\\) distinct passwords?",
                "answer": "We can use the scheme from before, the table can be represented as a hashtable or sorted, to allow for lookup via binary search. Then for every query hash, \\(hv\\), we repeat the process from part B, but lookups will take \\(O(\\frac{|S|}{k})\\) or \\(O(1)\\) depending on whether the table is implemented as a sorted list of entries or a hashtable, respectively. In practice, this is not always true. First, \\(hv\\) might be part of a chain that shares an endpoint with another chain, but is not present in the table. Additionally, chains can merge on collision. A query might need to search through all such chains that share the endpoint before finding the chain that contains \\(hv\\).\n\nOne might guess that each chain may store \\(k\\) unique passwords, and that therefore \\(\\frac{|S|}{k}\\) chains would store \\(|S|\\) distinct passwords. In practice, this is not true. Given \\(\\frac{|S|}{k}\\) chains of length \\(k\\), the number of distinct passwords will be much lower than \\(|S|\\) with high probability. The issue is the presence of collisions. For example, let’s consider the optimistic situation where the first \\(\\frac{|S|}{4k}\\) chains all contained completely unique passwords. In other words, one fourth of the password space has been successfully encoded without collision. Now, we want to lower bound the expected number of lost passwords. Consider the remaining \\(\\frac{3|S|}{4k}\\) chains. For each chain \\(i\\), we analyze the probability that one of the first \\(\\frac{k}{2}\\) elements in chain \\(i\\) collides with some element in the first half of a previous chain. In particular, if some collision occurs in the first half of chain \\(i\\) with an element in the first half of a preexisting chain, then at least \\(\\frac{k}{2}\\) passwords in chain \\(i\\) are lost by merging. It’s easy to see this is a lower bound on the losses, since this case only represents a subset of the cases where passwords are lost.\n\nFinally, the total number of expected passwords lost in the remaining chains will be:\n\n\\[\\sum_{i}^{\\frac{3|S|}{k}}E[\\text{lost passwords in chain $i$}] \\geq \\frac{3|S|}{4k} \\cdot \\frac{k}{2} \\cdot (1 - \\frac{1}{8})^{\\frac{k}{2}}\\]\n\nGiven \\(k \\geq 1000\\), which is highly reasonable, since otherwise the table would need at least \\(8.39 \\cdot 10^{14}\\) entries, the above formula yields that at least \\(\\frac{3|S|}{8}\\) passwords will not be unique due to merges. This follows from \\(\\frac{3|S|}{8} \\geq \\frac{3|S|}{4}\\), since we assumed that we had at least one fourth of all passwords in the table."
            },
            {
                "problem_number": "1d",
                "question": "Rainbow tables use a different and independent pseudorandom function fi mapping {0, 1}d to S for each step of the chain. Why does this increase the number of distinct hashes you expect the chains to contain?",
                "answer": "Using a family of pseudorandom functions \\(f_{i}\\), for each step in the chain greatly decreases the probability of merges. In particular, for a merge to occur, the collision must occur on the same step \\(j\\) of the chain. If you have length \\(l\\) chains, then any given collision has roughly a \\(\\frac{1}{l}\\) probability of causing a merge. With sufficiently large \\(l\\) (\\(l\\) should be quite large, otherwise the table's size will be unrealistic) using a family of pseudorandom functions significantly decreases the number of merges, and therefore increases the number of distinct passwords."
            },
            {
                "problem_number": "1e",
                "question": "How can Ben Bitdiddle modify his password storage scheme to make it infeasible for a precomputed rainbow table to significantly weaken his users’ passwords?",
                "answer": "One defense against rainbow tables is the use of salts. Instead of storing a passwords as \\(hash(pw)\\), Ben would store it as \\(hash(pw+salt)\\) where salt is a randomly generated string of greater than 48 bits. The salt can be stored in plainview, with the password hashes. The additional defense comes from the fact that Eve would need a rainbow table for each salt in order to obtain the passwords for every password in the database."
            }
        ]
    }
]
[
    {
        "problem_number": "2",
        "question": "Alice and Bob have taken 6.857, and would like to send confidential messages to each other in a way that meets the IND-CCA definition given there. Bob suggests the following method. Let \\(EncCBC(K,M)\\) denote the process of padding \\(M\\) with a 1 bit and then as many 0 bits as needed to make the message length a multiple of 128 bits, and then using AES in CBC mode to encrypt the result, using a randomly-chosen 128-bit IV. The result is: \\[EncCBC(K,M)=IV,C_{1},C_{2},\\ldots,C_{n}\\ .\\] Let \\(Rev(S)\\) denote the reverse of a sequence \\(S\\). That is, \\(S\\) is parsed as a sequence of 128-bit blocks (the length of \\(S\\) must be a multiple of 128 bits), and these blocks are re-arranged into reverse order. Bob then proposes that he and Alice secretly agree on two AES keys \\(K_{1}\\) and \\(K_{2}\\), and then define the encryption of a message \\(M\\) as \\[E(K_{1},K_{2};M)=EncCBC(K_{2},Rev(EncCBC(K_{1},M)))\\ .\\] The intent here is that the reversal avoids the problem noted in class, that 'ciphertext prefixes decode as prefixes of the message.' Show that this method does _not_ meet the IND-CCA security definition given in class. That is, show how the adversary can 'win' the security game against this method.",
        "subquestions": [
            {
                "problem_number": "2a",
                "question": "Show that this method does _not_ meet the IND-CCA security definition given in class. That is, show how the adversary can 'win' the security game against this method.",
                "answer": "**Theorem:** Bob's method \\(E\\) is _not_ IND-CCA secure. **Proof:** The adversary picks \\(m_{0}=0^{x},m_{1}=1^{x}\\) for large \\(x\\geq 3\\cdot 128\\) in phase I. Then \\(y=E_{K_{1},K_{2}}(m_{d})\\). Let \\(z=y\\) with the first bit flipped. Since \\(z\neq y\\), the adversary is allowed to ask for \\(D_{K_{1},K_{2}}(z)\\) in phase II. This correctly gives the first \\(128\\)-bit block of \\(m_{d}\\), revealing \\(d\\) (zeroes if \\(d=0\\) or ones if \\(d=1\\)). Therefore, the adversary wins the game. Why does this work? Consider the steps of \\(E\\), where \\(m_{d}\\) is divided into \\(n\\)\\(128\\)-bit blocks (\\(n\\geq 3\\)): 1. Start with \\(m_{d}=m_{1},\\ldots,m_{n}\\). 2. \\(\\mathsf{EncCBC}_{K_{1}}(m_{1},\\ldots,m_{n})=IV^{(1)},C_{1}^{(1)},\\ldots,C_{n}^{(1)}\\). 3. \\(\\mathsf{Rev}(IV^{(1)},C_{1}^{(1)},\\ldots,C_{n}^{(1)})=C_{n}^{(1)},\\ldots,C_{1}^{(1)},IV^{(1)}\\). 4. \\(\\mathsf{EncCBC}_{K_{2}}(C_{n}^{(1)},\\ldots,C_{1}^{(1)},IV^{(1)})=IV^{(2)},C_{1}^{(2)},\\ldots,C_{n}^{(2)},C_{n+1}^{(2)}\\). 5. End with \\(IV^{(2)},C_{1}^{(2)},\\ldots,C_{n}^{(2)},C_{n+1}^{(2)}=y\\). Now, consider the steps of \\(D\\), which reverses \\(E\\). 1. Start with \\(y=IV^{(2)},C_{1}^{(2)},\\ldots,C_{n}^{(2)},C_{n+1}^{(2)}\\). 2. \\(\\mathsf{DecCBC}_{K_{2}}(IV^{(2)},C_{1}^{(2)},\\ldots,C_{n}^{(2)},C_{n+1}^{(2)})=C_{n}^{(1)},\\ldots,C_{1}^{(1)},IV^{(1)}\\). 3. \\(\\mathsf{Rev}(C_{n}^{(1)},\\ldots,C_{1}^{(1)},IV^{(1)})=IV^{(1)},C_{1}^{(1)},\\ldots,C_{n}^{(1)}\\). 4. \\(\\mathsf{DecCBC}_{K_{1}}(IV^{(1)},C_{1}^{(1)},\\ldots,C_{n}^{(1)})=m_{1},\\ldots,m_{n}\\). 5. End with \\(m_{1},\\ldots,m_{n}=m_{d}\\). Finally, consider the steps of \\(D\\) when the input is \\(z\\) instead of \\(y\\) (the first bit is flipped). Denote any changed blocks in red. As we observed in Lecture 9, the bit flip only affects the decryption of the current block and the next block, since each decrypted block only depends on \\(C_{i}\\) and \\(C_{i-1}\\) (and only the first block depends on \\(IV\\)). 1. Start with \\(z=IV^{(2)},C_{1}^{(2)},\\ldots,C_{n}^{(2)},C_{n+1}^{(2)}\\). 2. \\(\\mathsf{DecCBC}_{K_{2}}(IV^{(2)},C_{1}^{(2)},\\ldots,C_{n}^{(2)},C_{n+1}^{(2)})=C_{n}^{(1)},\\ldots,C_{1}^{(1)},IV^{(1)}\\). 3. \\(\\mathsf{Rev}(C_{n}^{(1)},\\ldots,C_{1}^{(1)},IV^{(1)})=IV^{(1)},C_{1}^{(1)},\\ldots,C_{n}^{(1)}\\). 4. \\(\\mathsf{DecCBC}_{K_{1}}(IV^{(1)},C_{1}^{(1)},\\ldots,C_{n}^{(1)})=m_{1},\\ldots,m_{n}\\). 5. End with \\(m_{1},\\ldots,m_{n}\\). Therefore, the first block \\(m_{1}\\) of \\(m_{d}\\) is correct, revealing \\(d\\)."
            }
        ]
    },
    {
        "problem_number": "3",
        "question": "Ben Bitdiddle has designed a new cryptosystem called Kalns, but we suspect it might not be as strong as we would like to be. Therefore we ask your help to break it. In this problem we will be working with a finite field \\(\\mathsf{GF}_{16}\\). The elements of our field are all 4-bit strings. The field addition is computed as xor: \\(\\mathsf{GF}_{16}(x)+\\mathsf{GF}_{16}(y)=\\mathsf{GF}_{16}(x\\oplus y)\\). We provide the two tables describing addition and multiplication laws on the course web page. If you are curious, these tables are obtained by interpreting 4-bit field elements as degree \\(\\leq 4\\) polynomials over \\(\\mathsf{GF}_{2}\\) and performing addition and multiplication modulo the irreducible polynomial \\(x^{4}+x+1\\). However, for the purposes of this problem you do _not_ need to understand how our \\(\\mathsf{GF}_{16}\\) is constructed; the solutions we know assume black-box access to \\(\\mathsf{GF}_{16}\\). We have provided a \\(\\mathsf{GF}_{16}\\) implementation for you. Kalns is a 64-bit block cipher. The secret key consists of three parts: * an invertible 16-by-16 matrix \\(A\\) over \\(\\mathsf{GF}_{16}\\); * a 16-element vector \\(b\\) over \\(\\mathsf{GF}_{16}\\); and * a permutation (bijection) \\(S\\) that maps \\(\\mathsf{GF}_{16}\\) one-to-one and onto \\(\\mathsf{GF}_{16}\\). To encrypt a 64-bit block \\(B\\) we first break it up in sixteen 4-bit chunks and interpret each of them as a \\(\\mathsf{GF}_{16}\\) element. So block \\(B\\) corresponds to length 16 vector \\(x=(x_{0},\\ldots,x_{15})\\) over \\(\\mathsf{GF}_{16}\\). The encryptions consists of the following: \\(y=S(Ax+b)\\), where the permutation \\(S\\) is individually applied to each of 16 elements of \\(v=Ax+b\\). The 16-element vector \\(y\\) is later re-interpreted as 64-bit integer to obtain the encrypted block \\(B^{\\prime}\\).",
        "subquestions": [
            {
                "problem_number": "3a",
                "question": "Ben suspects that his cryptosystem is very secure. After all it has around \\(16^{16^{2}}\\cdot 16^{16}\\cdot 16!\\approx 21132.25\\) possible keys. However, we suspect that there are many equivalent keys. These keys have different values for \\((A,b,S)\\), but produce the same ciphertext for any given plaintext. Is our suspicion well-founded?",
                "answer": "Our suspicion is well founded, which we can see from a very simple analysis. Consider an original key combination \\((A, b, S)\\), where we call \\(Ax+b=v\\). Let us then consider a possible key combination \\((n*A, n*b, S')\\), where \\(n\\) is some number in \\(\\mathsf{GF}_{16}\\). The output of this new key pair will be \\(S^{\\prime}(nAx+nb)=S^{\\prime}(nv)\\). Thanks to the properties of \\(\\mathsf{GF}_{16}\\), we know that \\(n*m\\), where \\(n\\) is a \\(\\mathsf{GF}_{16}\\) value held constant and \\(m\\) is a \\(\\mathsf{GF}_{16}\\) value varied from 0 to 16, return all different values ranging from 0 to 16. (Of course, the case where \\(m = 0\\) maps to 0, but the other cases map more interestingly.) Thus, multiplying \\(v\\) by \\(n\\) can be considered as just an extra permutation, \\(P(v)\\). (This is true if \\(n\\) is nonzero, but we are simply choosing this to be the case.) This means we can just adjust \\(S'\\) to look like \\(S\\) after canceling out this original mapping, i.e \\(S^{\\prime}(x)=S(P^{-1}(x))\\), and we have an equivalent key pair. Thus we have generated several equivalent key pairs. It turns out that, since we have such freedom with \\(S\\), we can actually generate even more equivalent key pairs by basically generating new \\(v\\)'s and adjusting our \\(S\\) accordingly, as shown above. Thus, we know that there will be many equivalent key pairs."
            },
            {
                "problem_number": "3b",
                "question": "Describe a chosen-ciphertext attack on Kalns that recovers the unknown key \\((A,b,S)\\) or an equivalent key.",
                "answer": "Let's consider a series of possible inputs and outputs that we could try encrypting/decrypting, and consider the information gleaned from each. If we encrypt the vector \\(x_{0}=[0,0,0,0,...,0]\\), we will get \\(y_{0}=S(b)\\). Additionally, if we encrypt the vectors \\(x_{u}^{i}\\), which are the 16 unit vectors (i.e. the vectors with all 0's except a 1 at position \\(i\\)), we will get back \\(y_{u}^{i}=S(A^{i}+b)\\), where \\(A^{i}\\) is the \\(i\\)'th column of \\(A\\). We now have information about \\(A\\) and \\(b\\), but they are embedded in \\(S\\), the permutation. In order to get information about this, we can decrypt the values \\(y_{v}^{i}=[i,0,0,0,...0]\\). Reversing our algorithm, we can see that \\(x=A^{-1}(S^{-1}(y)-b)\\), which means we will get back \\(x_{v}^{i}=(A^{-1})^{0}(S^{-1}(y_{v}^{i})-b)\\). If we take the first element of these \\(x_{v}^{i}\\), we will get \\((A^{-1})^{0,0}(S^{-1}(i)-b^{0})\\), and if we take the differences \\(d^{i}=x_{v}^{0}-x_{v}^{i}\\), we will get \\((A^{-1})^{0,0}(S^{-1}(0)-S^{-1}(i))\\). Here, we take advantage of the properties of \\(\\mathsf{GF}_{16}\\) to define a new, valid permutation, \\(S^{\\prime}\\) such that \\(S^{\\prime-1}=(A^{-1})^{0,0}S^{-1}\\), such that the values \\(d^{i}\\) are actually differences between the inverse permutation values for 0 and \\(i\\). Defining \\(S'(0) = 0\\), we thus have a valid permutation that we have fully defined, and which we can construct an equivalent key pair using. (Recall from part a that we can do this because our permutation is correct up to a multiplicative constant!). Using this new \\(S'\\), we can decrypt \\(S(b)\\) such that \\(S^{\\prime-1}(S(b))=b^{\\prime}\\), and similarly extract each column of \\(A\\) as a column of a new matrix \\(A'\\). This new key combination \\((A^{\\prime},b^{\\prime},S^{\\prime})\\) is equivalent to the original combination \\((A,b,S)\\). Since we now have an equivalent key set to the original combination, we can freely encrypt and decrypt data as we please, completely compromising the Kalns encryption scheme."
            },
            {
                "problem_number": "3c",
                "question": "To demonstrate that your attack works, write an implementation that can break a randomly generated key. We have set up a web server that implements Kalns algorithm at http://6857.scripts.mit.edu/kalns/. Prove that your implementation works by getting your team's name on the list of successful teams. The server is powered by scripts.mit.edu shared hosting infrastructure. Please don't issue denial of service attacks or try to attack their servers.",
                "answer": "We have successfully implemented this algorithm. See MCRBFinalFast on http://6857.scripts.mit.edu/kalns/. Our code follows the exact process detailed in part b. The MITx submission site only allows one uploaded file, so we did not submit our actual code file, but the code we used is reproduced below using the verbatim tag.\n\n```python\nfrom kalns import *\n\ntokenString = remote_query('keygen?team=MCRBFinalFast')\n\ntheToken = tokenString[80:112]\n\nrk = RemoteKalns(theToken)\n\nb = int64_to_GF16_vec(rk.enc(0))\n\nr_unit = []\nfor i in range(16):\n    r_unit.append(int64_to_GF16_vec(rk.enc(2**(4*(15-i)))))\n\nA = []\nfor row in range(16):\n    A.append([])\n    for col in range(16):\n        A[row].append(r_unit[col][row])\n\niTimesAlnv = []\nfor i in range(16):\n    iTimesAlnv.append(int64_to_GF16_vec(rk.dec(i*(2**(4)))))\n\ntopVals = []\nfor i in range(16):\n    topVals.append(iTimesAlnv[i][0])\n\nfor i in range(1):\n    for ii in range(1):\n        AA = []\n        BB = []\n        s = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]\n        sinv = []\n        for iii in range(16):\n            x = topVals[iii]\n            x0 = topVals[0]\n            s[int((GF16(i) - ((x0-x)/GF16(ii+1))).val)] = int(iii)\n\n        for ij in range(16):\n            sinv.append(s.index(ij))\n        for k in range(16):\n            AA.append([])\n            for l in range(16):\n                AA[k].append(GF16(sinv[A[k][l].val]))\n            BB.append(GF16(sinv[b[k].val]))\n\n        for kk in range(16):\n            for ll in range(16):\n                newVar = AA[kk][ll] - BB[kk]\n                AA[kk][ll] = newVar\n\n        print \"s = \" + str(i) + \", Ainv[0][0] = \" + str(ii)\n        print rk.answer(AA, BB, s)\n```"
            }
        ]
    }
]
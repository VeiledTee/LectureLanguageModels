[
    {
        "problem_number": "2",
        "question": "It is well known that re-using a \"one-time pad\" can be insecure. This problem explores this issue, with some variations.\n\nIn this problem all characters are represented as 8-bit bytes with the usual US-ASCII encoding (e.g.\"A\" is encoded as 0x41). The bitwise exclusive-or of two bytes \\(x\\) and \\(y\\) is denoted \\(x\\oplus y\\).\n\nLet \\(M=(m_{1},m_{2},\\ldots,m_{n})\\) be a message, consisting of a sequence of \\(n\\) message bytes, to be encrypted. Let \\(P=(p_{1},p_{2},\\ldots,p_{n})\\) denote a pad, consisting of a coresponding sequence of (randomly chosen) \"pad bytes\" (key bytes).\n\nIn the usual one-time pad, the sequence \\(C=(c_{1},c_{2},\\ldots,c_{n})\\) of ciphertext bytes is obtained by xor-ing each message byte with the corresponding pad byte:\n\n\\[c_{i}=m_{i}\\oplus p_{i},\\mbox{ for }i=1\\ldots n\\;.\\]",
        "subquestions": [
            {
                "problem_number": "2a",
                "question": "Here are two 8-character English words encrypted with the same \"one-time pad\". What are the words? \\[\\begin{array}{l}\\mbox{\\tt e9~3a~e9~c5~fc~73~55~d5}\\\\ \\mbox{\\tt f4~3a~fe~c7~e1~68~4a~df}\\end{array}\\] Describe how you figured out the words.",
                "answer": "To decode the ciphertexts, we XORed them together, which gives \\(C_1 \\oplus C_2 = (M_1 \\oplus P) \\oplus (M_2 \\oplus P) = M_1 \\oplus M_2\\). Thus the pad \\(P\\) is irrelevant. Then we found a set of 8-character words from an English dictionary. For each \\(M_1\\) in this set, we constructed \\(M_2\\) by XORing \\(M_1\\) with \\(C_1 \\oplus C_2\\), since \\(M_1 \\oplus (C_1 \\oplus C_2) = M_1 \\oplus (M_1 \\oplus M_2) = M_2\\). Lastly, we checked if \\(M_2\\) was also in the set. If both \\(M_1\\) and \\(M_2\\) were in the set (as valid English words), then we outputted them.\n\nC1 = [0xe9, 0x3a, 0xe9, 0xc5, 0xfc, 0x73, 0x55, 0xd5]\nC2 = [0xf4, 0x3a, 0xfe, 0xc7, 0xe1, 0x68, 0x4a, 0xdf]\nM1_XOR_M2 = [c ^ d for c, d in zip(C1, C2)]\n...\nOutput of running the code:\nword1 = networks, word2 = security, pad = [135, 95, 157, 178, 147, 1, 62, 166]\nword1 = security, word2 = networks, pad = [154, 95, 138, 176, 142, 26, 33, 172]\n\nThough their ordering is indiscernible, the two words are security and networks."
            },
            {
                "problem_number": "2b",
                "question": "Ben Bitdiddle decided to fix this problem by making sure that you can't just \"cancel\" pad bytes by xor-ing the ciphertext bytes. In his scheme the key is still as long as the ciphertext. If we define \\(c_{0}=0\\) for notational convenience, then the ciphertext bytes \\(c_{1},c_{2},\\ldots,c_{n}\\) are obtained as follows: \\[c_{i}=m_{i}\\oplus((p_{i}+c_{i-1})\\bmod 256)\\ .\\] That is, each ciphertext byte is added to the next key byte and the addition result (modulo 256) is used to encrypt to the next plaintext byte. Ben is now confident he can reuse his pad, since \\((k_{i}+c_{i-1})\\bmod 256\\) will be different for different messages, so nobody would be able to cancel the \\(k_{i}\\)'s out. You are provided with otp-feedback.py, which contains an implementation of Ben's algorithm. You are also given the file tenciphs.txt, containing ten ciphertexts \\(C_{1},C_{2},\\ldots,C_{10}\\) produced by Ben, using the _same_ pad \\(P\\). You know that these messages contain valid English text. Submit the messages and the pad, along with a careful explanation of how you found them, and any code you used to help find the messages. The most important part is the explanation.",
                "answer": "Messages and Pad:\nWe stand today on the brink of a revolution in cryptography. Probabilistic encryption is the use of randomness in an ener Secure Sockets Layer (SSL), are cryptographic protocols that This document will detail a vulnerability in the ssh cryptog MIT developed Kerberos to protect network services provided NIST announced a competition to develop a new cryptographic Diffie-Hellman establishes a shared secret that can be used Public-key cryptography refers to a cryptographic system req The keys used to sign the certificates had been stolen from We hope this inspires others to work in this fascinating fie\n\npad = [119, 75, 116, 51, 85, 113, 72, 105, 76, 78, 114, 79, 84, 49, 71, 101, 71, 88, 116, 78, 113, 102, 113, 87, 84, 65, 51, 55, 99, 56, 107, 69, 116, 105, 110, 109, 97, 113, 79, 106, 122, 68, 66, 98, 77, 72, 112, 72, 55, 53, 104, 54, 99, 71, 87, 97, 68, 98, 112, 49]\n\nProcess:\nThis part's code was more interactive because, due to Ben's addition of feedback, we couldn't simply XOR the 10 ciphertexts together and look up possible messages in the dictionary. Our plan of attack was to first calculate all possible pad bytes (\\(p_i\\)'s) that would result in valid and likely English characters (letters and common punctuation) from all 10 ciphertexts.\n\nvalid_chars = set(range(65, 65 + 26) + range(97, 97 + 26) + [32, 44, 46, 63, 33, 45, 40, 41])\n\n...\nOutput of running the code:\nmessages = ['We stand today on ', 'Probabilistic encr', 'Secure Sockets Lay', 'This document will', 'MIT developed Kerb', 'NIST announced a c', 'Diffie-Hellman est', 'Public-key cryptog', 'The keys used to s', 'We hope this inspi'], pad = [119, 75, 116, 51, 85, 113, 72, 105, 76, 78, 114, 79, 84, 49, 71, 101, 71, 88]\n\nRepeating this process 4x, we eventually got the desired output... The keys used to sign the certificates had been stolen from We hope this inspires others to work in this fascinating fie"
            }
        ]
    },
    {
        "problem_number": "3",
        "question": "In the previous problem, we saw how to attack a scheme in which a one-time pad, or a scheme like it, is reused. This problem will walk you through how rare pad reuse for the standard one-time pad (not the previous part's scheme) can be efficiently detected. We will look at the extreme case in which a pad is reused just once.\n\nThe following fact may be useful in this problem: Let \\(R_{p}(n)\\) be the longest run of heads in \\(n\\) coin flips, each of which is heads with probability \\(p\\). With high probability as \\(n\\) grows, \\(R_{p}(n)\\) is between \\(\\log_{\\frac{1}{p}}n - \\log_{\\frac{1}{p}}\\ln\\ln n\\) and \\(\\log_{\\frac{1}{p}}n + \\log_{\\frac{1}{p}}\\ln n\\). Note: you are not responsible for this paper; it is provided as a reference only.",
        "subquestions": [
            {
                "problem_number": "3a",
                "question": "Suppose you are given \\(poly(n)\\) \\(n\\)-bit ciphertexts \\(c_{1},\\ldots,c_{l}\\), each of which are properly encrypted with an independently uniformly randomly chosen one-time pad. Show that with high probability, the length of the longest repeated bitstring (i.e. a substring of both \\(c_{i}\\) and \\(c_{j}\\) for some \\(i\neq j\\)) is less than \\(\\log_{2}n + \\log_{2}\\ln n\\).",
                "answer": "We are given \\(f(n)=\\operatorname{poly}(n)\\)\\(n\\)-bit ciphertexts \\(c_{1},\\ldots,c_{f(n)}\\), each from a unique plaintext/pad pair. Our goal is to show that the upper bound on the longest run of matching bits between any two ciphertexts, at any offset, is \\(\\log_{2}\\left(n\\ln n\\right)\\) with high probability.\n\nFirst, consider a pair of ciphertexts \\(c_{i}\\) and \\(c_{j}\\) (\\(i\neq j\\)) with no offset. The longest run of matching bits within the \\(n\\) bits of \\(c_{i}\\) and \\(c_{j}\\) is modeled as the longest run of heads in \\(n\\) coin flips (probability \\(p=0.5\\)). Using the provided fact, the longest run \\(R_{0.5}(n)\\) is less than \\(\\log_{2}\\left(n\\ln n\\right)\\) with high probability.\n\nFor offsets \\(k\\) (\\(0\\leq k<n\\)), the longest run in \\(n-k\\) bits still satisfies \\(R_{0.5}(n-k)\\leq \\log_{2}\\left(n\\ln n\\right)\\). Considering all \\(\\binom{f(n)}{2}\\) pairs and \\(2n-1\\) offsets, the total number of comparisons is \\(\\operatorname{poly}(n)\\). By union bound, the probability that any pair/offset exceeds the bound is negligible, ensuring the upper bound holds with high probability."
            },
            {
                "problem_number": "3b",
                "question": "We have collected data on the average length of the longest run of identical characters in identical positions in passages of English text by randomly sampling from the collected works of American writer Winston Churchill. You can find a graph of run length (in characters) versus log of the passage length in characters at http://courses.csail.mit.edu/6.857/2014/files/run_lengths.png. How do these run lengths compare to the previous part's upper bound if English plaintext is US-ASCII encoded?",
                "answer": "Assuming US-ASCII encoding (7 bits per character), the upper bound in bits translates to \\(\\frac{1}{7}\\log_{2}(7n\\ln 7n)\\) in characters. Plotting this against Churchill's data shows that English plaintext exhibits longer average runs than the ciphertext upper bound for large \\(n\\). This is due to language redundancy (e.g., frequent 'e', predictable letter pairs). While ciphertext runs are bounded by \\(\\log_{2}\\left(n\\ln n\\right)\\), English runs grow faster, surpassing the bound when \\(\\log_{2}n > 9\\). The graph highlights this divergence as exponential (plaintext) vs. linear (ciphertext upper bound)."
            },
            {
                "problem_number": "3c",
                "question": "Show that given \\(poly(n)\\) \\(n\\)-bit ciphertexts with total length \\(N\\) and one instance of pad reuse, you can find the two ciphertexts which share a key in time which is \\(\\tilde{O}(N)\\) in the total ciphertext length. This means that your solution should run in \\(O(N\\log^{c}N)\\) time for some constant \\(c\\).\n\n*Hint: You may wish to use suffix trees...*",
                "answer": "**Algorithm:**\n1. **Concatenate Ciphertexts:** Append unique terminators to each ciphertext and concatenate them into a single string \\(S\\).\n2. **Build Suffix Tree:** Construct a suffix tree for \\(S\\), which takes \\(O(N\\log N)\\) time.\n3. **Find Longest Repeated Substring:** Traverse the suffix tree to identify the deepest internal node, corresponding to the longest repeated substring. If its length \\(d > \\log_{2}\\left(n\\ln n\\right)\\), pad reuse is detected.\n4. **Identify Culprit Ciphertexts:** Trace paths from the node to leaves containing unique terminators, revealing the two ciphertexts sharing the pad.\n\n**Correctness:** Pad reuse creates a long common substring in ciphertexts (exceeding the bound from part (a)), while independent pads do not. Suffix trees efficiently capture this via longest repeated substring.\n\n**Running Time:** Suffix tree construction dominates at \\(O(N\\log N)\\), achieving quasilinear time \\(\\tilde{O}(N)\\)."
            }
        ]
    }
]
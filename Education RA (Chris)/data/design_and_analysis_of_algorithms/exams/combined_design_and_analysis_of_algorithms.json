[
    {
        "question": "Using similar techniques used in Strassen's matrix multiplication algorithm, the Floyd-Warshall algorithm's running time can be improved to O(Vlog2 7).",
        "answer": "False. There is no way to define negation.",
        "problem_number": "1",
        "context": "Problem 1. True or False. [40 points] (10 parts)\nCircle T or F for each of the following statements to indicate whether the statement is true or false and briefly explain why.\n(a)",
        "custom_id": "441462sols000"
    },
    {
        "question": "For graphs G = (V, E) where E = O(V1.5), Johnson's algorithm is asymptotically faster than Floyd-Warshall.",
        "answer": "True. O(VE + V2 log V) = 0(V\u00b3) when E = o(V2).",
        "problem_number": "1",
        "context": "Problem 1. True or False. [40 points] (10 parts)\nCircle T or F for each of the following statements to indicate whether the statement is true or false and briefly explain why.\n(b)",
        "custom_id": "441462sols001"
    },
    {
        "question": "Consider the directed graph where each vertex represents a subproblem in a dynamic program, and there is an edge from p to q if and only if subproblem p depends on (recursively calls) subproblem q. Then this graph is a directed rooted tree.",
        "answer": "False. It is a Directed Acyclic Graphic (DAG).",
        "problem_number": "1",
        "context": "Problem 1. True or False. [40 points] (10 parts)\nCircle T or F for each of the following statements to indicate whether the statement is true or false and briefly explain why.\n(c)",
        "custom_id": "441462sols002"
    },
    {
        "question": "In a connected, weighted graph, every lowest weight edge is always in some minimum spanning tree.",
        "answer": "True. It can be the first edge added by Kruskal's algorithm.",
        "problem_number": "1",
        "context": "Problem 1. True or False. [40 points] (10 parts)\nCircle T or F for each of the following statements to indicate whether the statement is true or false and briefly explain why.\n(d)",
        "custom_id": "441462sols003"
    },
    {
        "question": "For a connected, weighted graph with n vertices and exactly n edges, it is possible to find a minimum spanning tree in O(n) time.",
        "answer": "True. This graph only contains one cycle, which can be found by a DFS. Just remove the heaviest edge in that cycle.",
        "problem_number": "1",
        "context": "Problem 1. True or False. [40 points] (10 parts)\nCircle T or F for each of the following statements to indicate whether the statement is true or false and briefly explain why.\n(e)",
        "custom_id": "441462sols004"
    },
    {
        "question": "For a flow network with an integer capacity on every edge, the Ford\u2013Fulkerson algorithm runs in time O((V + E) |f|) where |f| is the maximum flow.",
        "answer": "True. There can be O(|f|) iterations because each iteration increases the flow by at least 1.",
        "problem_number": "1",
        "context": "Problem 1. True or False. [40 points] (10 parts)\n(f)",
        "custom_id": "441462sols005"
    },
    {
        "question": "Let C = (S, V \\ S) be a minimum cut in a flow network. If we strictly increase the capacity of every edge across C, then the maximum flow of the network must increase.",
        "answer": "False. There could be another min cut whose capacity does not change. Then the max flow remains the same.",
        "problem_number": "1",
        "context": "Problem 1. True or False. [40 points] (10 parts)\n(g)",
        "custom_id": "441462sols006"
    },
    {
        "question": "Every linear program has a unique optimal solution.",
        "answer": "False. There can be many optimal solutions if the objective function is parallel to one of the constrains.",
        "problem_number": "1",
        "context": "Problem 1. True or False. [40 points] (10 parts)\n(h)",
        "custom_id": "441462sols007"
    },
    {
        "question": "3SAT cannot be solved in polynomial time, even if P = NP.",
        "answer": "False. If P = NP, then all problems in P are also NP-hard, and these problems have polynomial-time algorithms.",
        "problem_number": "1",
        "context": "Problem 1. True or False. [40 points] (10 parts)\n(i)",
        "custom_id": "441462sols008"
    },
    {
        "question": "Repeatedly selecting a vertex of maximum degree, and deleting the incident edges, is a 2-approximation algorithm for Vertex Cover.",
        "answer": "False: it can be as bad as a log-log approximation, see L17 notes.",
        "problem_number": "1",
        "context": "Problem 1. True or False. [40 points] (10 parts)\n(j)",
        "custom_id": "441462sols009"
    },
    {
        "question": "Draw the shortest path from Boston to New York in the following graph if m = \u221e. Charging stations are marked as circles.",
        "answer": "See image on page 4 of the pdf.",
        "problem_number": "2",
        "context": "Problem 2. Who Charged the Electric Car? [20 points] (3 parts)\nProf. Musk is driving his Nikola electric car from Boston to New York. He wants to take the shortest path, but his car can only drive m miles before needing to charge. Fortunately, there are Furiouscharger charging stations on the way from Boston to New York, which instantaneously charge the battery to full.\nThe road network is given to you as a weighted undirected graph G = (V, E, w) along with the subset CC V of vertices that have charging stations. Each weight w(e) denotes the (positive) length of road e. The goal is to find a shortest path from node s \u2208 V to node t \u2208 V that does not travel more than m miles between charging stations. Assume that s, t \u2208 C.\n(a)",
        "custom_id": "441462sols010"
    },
    {
        "question": "Draw the shortest path from Boston to New York in the following (identical) graph if m = 100.",
        "answer": "See image on page 4 of the pdf.",
        "problem_number": "2",
        "context": "Problem 2. Who Charged the Electric Car? [20 points] (3 parts)\nProf. Musk is driving his Nikola electric car from Boston to New York. He wants to take the shortest path, but his car can only drive m miles before needing to charge. Fortunately, there are Furiouscharger charging stations on the way from Boston to New York, which instantaneously charge the battery to full.\nThe road network is given to you as a weighted undirected graph G = (V, E, w) along with the subset CC V of vertices that have charging stations. Each weight w(e) denotes the (positive) length of road e. The goal is to find a shortest path from node s \u2208 V to node t \u2208 V that does not travel more than m miles between charging stations. Assume that s, t \u2208 C.\n(b)",
        "custom_id": "441462sols011"
    },
    {
        "question": "Give an algorithm to solve the problem. For full credit, your algorithm should run in O(VE + V2 log V) time.",
        "answer": "Our algorithm consists of two steps \u2013 the first step involves running Johnson's algorithm on the original graph G to obtain shortest path lengths for every pair of vertices. Let d(u, v) represent the length of the shortest path between vertices u and v in G.\nFor the second step, we build a graph G' with vertex set C. For every pair of vertices u and v in the new graph G', draw an edge between u and v with weight \u03b4(u, v) if \u03b4(u, v) \u2264 m and \u221e otherwise.\nNow, run Dijkstra's algorithm on G' between Boston and New York to get the shortest path. (Note that New York and Boston have charging stations and so are vertices in the graph G').\nRunning Johnson's algorithm on the original graph G takes O(VE + V\u00b2 log V). Creating the graph G' takes O(E) time, and running Dijkstra's algorithm on G' takes O(V2 + V log V) time; this gives a total runtime complexity of O(VE + V\u00b2 log V).",
        "problem_number": "2",
        "context": "Problem 2. Who Charged the Electric Car? [20 points] (3 parts)\nProf. Musk is driving his Nikola electric car from Boston to New York. He wants to take the shortest path, but his car can only drive m miles before needing to charge. Fortunately, there are Furiouscharger charging stations on the way from Boston to New York, which instantaneously charge the battery to full.\nThe road network is given to you as a weighted undirected graph G = (V, E, w) along with the subset CC V of vertices that have charging stations. Each weight w(e) denotes the (positive) length of road e. The goal is to find a shortest path from node s \u2208 V to node t \u2208 V that does not travel more than m miles between charging stations. Assume that s, t \u2208 C.\n(c)",
        "custom_id": "441462sols012"
    },
    {
        "question": "Give a greedy algorithm that outputs an ordering of the psets that minimizes the total penalty for all the psets. Analyze the running time and prove correctness.",
        "answer": "Sort by increasing di/ci and do the problem sets in that order. This takes O(N log N) time.\nProof \u2013 If unsorted, we can improve by swapping.\ndi/ci > dj/cjcjdi + (cidi + cjdj) > cidj + (cidi + cjdj)\n=\ncj(di+dj) + cidi > ci(di + dj) + cjdj",
        "problem_number": "3",
        "context": "Problem 3. Planning Ahead [10 points] (1 part)\nYou have N psets due right now, but you haven't started any of them, so they are all going to be late. Each pset requires di days to complete, and has a cost penalty of ci per day. So if pset i ends up being finished t days late, then it incurs a penalty of t \u00b7 ci. Assume that once you start working on a pset, you must work on it until you finish it, and that you cannot work on multiple psets at the same time.",
        "custom_id": "441462sols013"
    },
    {
        "question": "First look at the special case where the maze is just a single path of length |E| from s to t, and all the edges have capacity 1 (see below). Exactly how many nights are required for the teens to escape?",
        "answer": "|E| + m - 1 or |V| + m \u2013 2. Em or Vm will get partial credits.",
        "problem_number": "4",
        "context": "Problem 4. Maze Marathoner [20 points] (3 parts)\nA group of m teens need to escape a maze, represented by a directed graph G = (V, E). The teens all start at a common vertex s \u2208 V, and all need to get to the single exit at t \u2208 V. Every night, each teen can choose to remain where they are, or traverse an edge to a neighboring vertex (which takes exactly one night to traverse). However, each edge e \u2208 E has an associated capacity c(e), meaning that at most c(e) teens can traverse the edge during the same night. The goal is to minimize the number of nights required for all teens to escape by reaching the goal t.\n(a)",
        "custom_id": "441462sols014"
    },
    {
        "question": "Give an algorithm to calculate the minimum number of nights to escape, by making calls to the magic algorithm. Analyze your time complexity in terms of V, E, m, a, and T(V, E, m).",
        "answer": "Do a binary search. A sequential scan will get partial credits.\nThe maximum number of nights can be bounded by O(E+m) (or O(V+m), O(Em))\naccording to part(a). Therefore, we need to run the \u201cmagic\u201d algorithm O(log(E+m))\ntimes. Each run takes no more than O((E + m)\u00baT(V, E, m)) time. So in total, the\nruntime is O((E + m)\u00ba log(E + m)T(V, E, m)).",
        "problem_number": "4",
        "context": "Problem 4. Maze Marathoner [20 points] (3 parts)\nA group of m teens need to escape a maze, represented by a directed graph G = (V, E). The teens all start at a common vertex s \u2208 V, and all need to get to the single exit at t \u2208 V. Every night, each teen can choose to remain where they are, or traverse an edge to a neighboring vertex (which takes exactly one night to traverse). However, each edge e \u2208 E has an associated capacity c(e), meaning that at most c(e) teens can traverse the edge during the same night. The goal is to minimize the number of nights required for all teens to escape by reaching the goal t.\n(b)",
        "custom_id": "441462sols015"
    },
    {
        "question": "Now give the \u201cmagic\u201d algorithm, and analyze its time complexity.",
        "answer": "Model this as a max flow problem. Construct a graph G' = (V', E') where\nV' = {(v, i) | v \u2208 V, 0 \u2264 i \u2264 k}. For all 0 \u2264 i \u2264 k\u22121, connect (v, i) to (v, i+1) with\ncapacity (or m); this represents teens can stay at a vertex for the night. For every\nedge (u, v) in the original graph, connect (u, i) to (v, i + 1) with capacity c((u, v));\nthis represents c((u, v)) teens can travel from u to v in a night.\nThe new source s' is the vertex (s, 0) and the new sink t' is the vertex (t, k \u2212 1). If the\nmax flow from s' to t' is no less than m, then people can escape within k nights.\nRuntime: Both of the following are accepted.\nThere are V = O(kV') vertices and E' = O(k(V + E)) edges in G'. Applying\nEdmonds-Karp algorithm, the total time complexity is O(VE2) = O(k3V(V + E)\u00b2).\nIf using Ford-Fulkerson runtime, notice that we can actually stop if the max flow\nreaches m. So at most m iterations are needed. Runtime can be O(m(V' + E')) =\nO(mk(V + E)).",
        "problem_number": "4",
        "context": "Problem 4. Maze Marathoner [20 points] (3 parts)\nA group of m teens need to escape a maze, represented by a directed graph G = (V, E). The teens all start at a common vertex s \u2208 V, and all need to get to the single exit at t \u2208 V. Every night, each teen can choose to remain where they are, or traverse an edge to a neighboring vertex (which takes exactly one night to traverse). However, each edge e \u2208 E has an associated capacity c(e), meaning that at most c(e) teens can traverse the edge during the same night. The goal is to minimize the number of nights required for all teens to escape by reaching the goal t.\n(c)",
        "custom_id": "441462sols016"
    },
    {
        "question": "Give an algorithm to find a driver assignment di \u2208 Si for each day i such that no person j has to drive more than their limit lj. (The algorithm should output \u201cno\u201d if there is no such assignment.)",
        "answer": "First, we create a graph with following vertices:\n1.a super source s and a super sink t\n2.vertex pi for each person who wants to carpool\n3.vertex dj for each day of the class.\nThen create the following edges:\n1.s to pi with capacity of lj\n2.pi to dj with capacity of 1 if person i needs to carpool on day j\n3.d; to t with weight 1 for all j.\nFinally, run max flow from s to t, and find f. If |f| = m, return that person i will drive on day j if\nthe edge (pi, dj) has non-zero flow. If |f| < m, then return no valid assignment.",
        "problem_number": "5",
        "context": "Problem 5. 6.046 Carpool [10 points] (1 part)\nThe n people in your dorm want to carpool to 34-101 during the m days of 6.046. On day i, some subset S of people actually want to carpool (i.e., attend lecture), and the driver di must be selected from St. Each person j has a limited number of days l; they are willing to drive.",
        "custom_id": "441462sols017"
    },
    {
        "question": "Give a polynomial-time algorithm to determine whether a directed graph G contains either a cycle or a Hamiltonian path (or both).",
        "answer": "To solve the problem, we simply run DFS on G. If a cycle exists, DFS will traverse a vertex twice and can report the cycle. If no cycle exists, then the graph is a DAG.\nIf the graph is a DAG, then we can run a topological sort on the graph. If there is a complete, or unique, ordering of every vertex in the graph, the graph has a Hamiltonian Path, and we accept the graph.",
        "problem_number": "6",
        "context": "Problem 6. Paths and/or Cycles [20 points] (2 parts)\nA Hamiltonian path on a directed graph G = (V, E) is a path that visits each vertex in V exactly once. Consider the following variants on Hamiltonian path:\n(a)",
        "custom_id": "441462sols018"
    },
    {
        "question": "Show that it is NP-hard to decide whether a directed graph G' contains both a cycle and a Hamiltonian Path, by giving a reduction from the HAMILTONIAN PATH problem: given a graph G, decide whether it has a Hamiltonian path. (Recall from recitation that the HAMILTONIAN PATH problem is NP-complete.)",
        "answer": "We construct a graph G' = (V', E') from G, where\nV' = {U1, U2, U3} UV\nU\nE' = {(41, 42), (\u0418\u2082, \u0418\u0437), (\u0438\u0437, \u0418\u2081) } \u222a {(u\u2081, V) : v \u2208 V} U E\nG' always has a cycle of length 3 - (U1, U2, U3). For any Hamiltonian Path P in G,\n(u2, 43, 41, P) is a Hamiltonian Path in G'. For any Hamiltonian Path P' in G', P'\nmust be of the form (u2, 43, 41, P), where P is a Hamiltonian path for G. Thus in all\ncases, solving B(G') is equivalent to solving Hamiltonian Path for G.",
        "problem_number": "6",
        "context": "Problem 6. Paths and/or Cycles [20 points] (2 parts)\nA Hamiltonian path on a directed graph G = (V, E) is a path that visits each vertex in V exactly once. Consider the following variants on Hamiltonian path:\n(b)",
        "custom_id": "441462sols019"
    },
    {
        "question": "With all equal-sized intervals, a greedy algorithm based on earliest start time will always select the maximum number of compatible intervals.",
        "answer": "True. The algorithm is equivalent to the earliest finish time algorithm.",
        "problem_number": "1(a)",
        "context": "Problem 1. True or False.\nCircle T or F for each of the following statements to indicate whether the statement is true or false and briefly explain why.",
        "custom_id": "5b6cd1sols000"
    },
    {
        "question": "The problem of weighted interval scheduling can be solved in O(n log n) time using dynamic programming.",
        "answer": "True. The algorithm was covered in recitation.",
        "problem_number": "1(b)",
        "context": "Problem 1. True or False.\nCircle T or F for each of the following statements to indicate whether the statement is true or false and briefly explain why.",
        "custom_id": "5b6cd1sols001"
    },
    {
        "question": "If we divide an array into groups of 3, find the median of each group, recursively find the median of those medians, partition, and recurse, then we can obtain a linear-time median-finding algorithm.",
        "answer": "False. T(n) = T(n/3) + T(2n/3) + O(n) does not solve to T(n) = O(n). The array has to be broken up into groups of at least 5 to obtain a linear-time algorithm.",
        "problem_number": "1(c)",
        "context": "Problem 1. True or False.\nCircle T or F for each of the following statements to indicate whether the statement is true or false and briefly explain why.",
        "custom_id": "5b6cd1sols002"
    },
    {
        "question": "If we used the obvious \u0398(n\u00b2) merge algorithm in the divide-and-conquer convex-hull algorithm, the overall time complexity would be O(n\u00b2 log n).",
        "answer": "False. The time complexity would satisfy the recurrence T(n) = 2T(n/2) + \u0398(n\u00b2), which solves to (n\u00b2) by the Master Theorem.",
        "problem_number": "1(d)",
        "context": "Problem 1. True or False.\nCircle T or F for each of the following statements to indicate whether the statement is true or false and briefly explain why.",
        "custom_id": "5b6cd1sols003"
    },
    {
        "question": "Van Emde Boas sort (where we insert all numbers, find the min, and then repeatedly call SUCCESSOR) can be used to sort n = lg u numbers in O(lg u\u00b7\nlg lg lg u) time.",
        "answer": "False. Inserting into the tree and then finding all the successors will take n lg lg(u) time, which in terms of u is lg(u) \u00b7 lg lg(u).",
        "problem_number": "1(e)",
        "context": "Problem 1. True or False.\nCircle T or F for each of the following statements to indicate whether the statement is true or false and briefly explain why.",
        "custom_id": "5b6cd1sols004"
    },
    {
        "question": "Van Emde Boas on n integers between 0 and u 1 supports successor queries in O(lg lg u) worst-case time using O(n) space.",
        "answer": "False. We use (u) space or do randomization.",
        "problem_number": "1(f)",
        "context": "Problem 1. True or False.\nCircle T or F for each of the following statements to indicate whether the statement is true or false and briefly explain why.",
        "custom_id": "5b6cd1sols005"
    },
    {
        "question": "In the potential method for amortized analysis, the potential energy should never go negative.",
        "answer": "True.",
        "problem_number": "1(g)",
        "context": "Problem 1. True or False.\nCircle T or F for each of the following statements to indicate whether the statement is true or false and briefly explain why.",
        "custom_id": "5b6cd1sols006"
    },
    {
        "question": "The quicksort algorithm that uses linear-time median finding to run in worst-case O(n log n) time requires O(n) auxiliary space.",
        "answer": "False. It can be implemented with O(log n) auxiliary space.",
        "problem_number": "1(h)",
        "context": "Problem 1. True or False.\nCircle T or F for each of the following statements to indicate whether the statement is true or false and briefly explain why.",
        "custom_id": "5b6cd1sols007"
    },
    {
        "question": "Searching in a skip list takes O(log n) time with high probability, but could take \u03a9(2n) time with nonzero probability.",
        "answer": "True. A skip list could be of any height with nonzero probability, depending on its random choices.",
        "problem_number": "1(i)",
        "context": "Problem 1. True or False.\nCircle T or F for each of the following statements to indicate whether the statement is true or false and briefly explain why.",
        "custom_id": "5b6cd1sols008"
    },
    {
        "question": "The following collection H = {h1,h2, h3} of hash functions is uni-versal, where each hash function maps the universe U = {A, B, C, D} of keys into the range {0, 1, 2} according to the following table:\nX\nABCD\nh\u2081(x) 1011\nh2(x) 0101\nh3(x) 2 2 10",
        "answer": "False. A and C collide with probability 2/3.",
        "problem_number": "1(j)",
        "context": "Problem 1. True or False.\nCircle T or F for each of the following statements to indicate whether the statement is true or false and briefly explain why.",
        "custom_id": "5b6cd1sols009"
    },
    {
        "question": "Point out Ben's mistake in one sentence; no calculation needed. (Ben swears he has calculated FFT F and inverse FFT F-\u00b9 correctly.)",
        "answer": "The resulting polynomial is of degree 2, so Ben need to pad a and b with zeroes. (Or Ben need at least 3 samples to do FFT).",
        "problem_number": "2",
        "context": "Problem 2. Fast Fourier Transform (FFT).\nBen Bitdiddle is trying to multiply two polynomials using the FFT. In his trivial example, Ben sets\na = (0, 1) and b = (0, 1), both representing 0 + x, and calculates:\nA = F(a) = B = F(b) = (1, \u22121),\nC = A * B = (1, 1),\nc = F\u00af\u00b9(C) = (1, 0).\nSo c represents 1 + 0\u00b7x, which is clearly wrong.",
        "custom_id": "5b6cd1sols010"
    },
    {
        "question": "Give the fastest data structure you can for this problem, measured according to worst-case time.",
        "answer": "Initialization takes O(nlg(1g(n))) time to insert all the yellow elements into a VEB tree, V.\nMore importantly, each operation takes O(lg lg(n)) time. When a user asks to MARK-YELLOW(i), then call V.insert(i) which takes O(lglg(n)) time. When a user asks to MARK-GREY(i), then call V.delete(i) which takes O(lglg(n)) time. When a user asks to NEXT-YELLOW(i), then call V.successor(i) which takes O(lg lg(n)) time.",
        "problem_number": "3",
        "context": "Problem 3. Yellow Brick Road.\nProf. Gale is developing a new Facebook app called \u201cYellow Brick Road\u201d for maintaining a user's timeline, here represented as a time-ordered list eo, e1, ..., en\u22121 of n (unchanging) events. (In Facebook, events can never be deleted, and for the purposes of this problem, don't worry about insertions either.) The app allows the user to mark an event ei as yellow (important) or grey (unimportant); initially all events are grey. The app also allows the user to jump to the next yellow event that comes after the event ei currently on the screen (which may be yellow or grey). More formally, you must support the following operations:\n1. MARK-YELLOW(i): Mark ei yellow.\n2. MARK-GREY(i): Mark ei grey.\n3. NEXT-YELLOW(i): Find the smallest j > i such that ej is yellow.",
        "custom_id": "5b6cd1sols011"
    },
    {
        "question": "Design a data structure to maintain a set S of n distinct integers that supports the following two operations:\n1. INSERT(x, S): insert integer x into S.\n2. REMOVE-BOTTOM-HALF(S): remove the smallest [$\\frac{n}{2}$] integers from S.\nDescribe your algorithm and give the worse-case time complexity of the two operations. Then carry out an amortized analysis to make INSERT(x, S) run in amortized O(1) time, and REMOVE-BOTTOM-HALF(S) run in amortized 0 time.",
        "answer": "Use a singly linked list to store those integers. To implement INSERT(x, S), we append the new integer to the end of the linked list. This takes (1) time. To implement REMOVE-BOTTOM-HALF(S), we use the median finding algorithm taught in class to find the median number, and then go through the list again to delete all the numbers smaller or equal than the median. This takes \u0398(n) time.\nSuppose the runtime of REMOVE-BOTTOM-HALF(S) is bounded by cn for some constant c. For amortized analysis, use \u03a6 = 2cn as our potential function. Therefore, the amortized cost of an insertion is 1 + \u0394\u03a6 = 1 + 2c = \u0398(1). The amortized cost of REMOVE-BOTTOM-HALF(S) is\ncn + \u2206\u03a6 = cn + (\u22122c \u00d7 $\\frac{n}{2}$) = 0.",
        "problem_number": "4",
        "context": "Problem 4. Amortized Analysis.",
        "custom_id": "5b6cd1sols012"
    },
    {
        "question": "Describe an O(n)-time randomized algorithm for testing whether p(x) \u00b7 q(x) = r(x) that satisfies the following properties:\n1. If the two sides are equal, the algorithm outputs YES.\n2. If the two sides are unequal, the algorithm outputs NO with probability at least $\\frac{1}{2}$.",
        "answer": "Pick a value a \u2208 [1, 4n], and check whether p(a)q(a) = r(a). The algorithm outputs YES if the two sides are equal, and NO otherwise. It takes O(n) time to evaluate the three polynomials of degree O(n). Thus the overall running time of the algorithm is O(n).",
        "problem_number": "5(a)",
        "context": "Problem 5. Verifying Polynomial Multiplication.\nThis problem will explore how to check the product of two polynomials. Specifically, we are given three polynomials:\np(x) = anx\u00b2 + an\u22121xn\u22121 + \u00b7\u00b7\u00b7 + ao,\nq(x) = bnxn + bn-1xn-1 + ... + bo,\nr(x) = C2nx2n + C2n\u22121x2n\u22121 + \u00b7\u00b7\u00b7 + Co.\nWe want to check whether p(x) \u00b7 q(x) = r(x) (for all values x). Via FFT, we could simply compute p(x)\u00b7 q(x) and check in O(n log n) time. Instead, we aim to achieve O(n) time via randomization.",
        "custom_id": "5b6cd1sols013"
    },
    {
        "question": "Prove that your algorithm satisfies Property 1.",
        "answer": "If p(x) \u00b7 q(x) = r(x), then both sides will evaluate to the same thing for any input.",
        "problem_number": "5(b)",
        "context": "Problem 5. Verifying Polynomial Multiplication.\nThis problem will explore how to check the product of two polynomials. Specifically, we are given three polynomials:\np(x) = anx\u00b2 + an\u22121xn\u22121 + \u00b7\u00b7\u00b7 + ao,\nq(x) = bnxn + bn-1xn-1 + ... + bo,\nr(x) = C2nx2n + C2n\u22121x2n\u22121 + \u00b7\u00b7\u00b7 + Co.\nWe want to check whether p(x) \u00b7 q(x) = r(x) (for all values x). Via FFT, we could simply compute p(x)\u00b7 q(x) and check in O(n log n) time. Instead, we aim to achieve O(n) time via randomization.",
        "custom_id": "5b6cd1sols014"
    },
    {
        "question": "Prove that your algorithm satisfies Property 2.",
        "answer": "s(x) = r(x) - p(x) \u00b7 q(x) is a degree-2n polynomial, and thus has at most 2n roots. Then\nPr{s(a) = 0} \u2264 $\\frac{2n}{4\u03b7}$ = $\\frac{1}{2}$",
        "problem_number": "5(c)",
        "context": "Problem 5. Verifying Polynomial Multiplication.\nThis problem will explore how to check the product of two polynomials. Specifically, we are given three polynomials:\np(x) = anx\u00b2 + an\u22121xn\u22121 + \u00b7\u00b7\u00b7 + ao,\nq(x) = bnxn + bn-1xn-1 + ... + bo,\nr(x) = C2nx2n + C2n\u22121x2n\u22121 + \u00b7\u00b7\u00b7 + Co.\nWe want to check whether p(x) \u00b7 q(x) = r(x) (for all values x). Via FFT, we could simply compute p(x)\u00b7 q(x) and check in O(n log n) time. Instead, we aim to achieve O(n) time via randomization.",
        "custom_id": "5b6cd1sols015"
    },
    {
        "question": "Design a randomized algorithm to check whether p(x) \u00b7 q(x) = r(x) that is correct with probability at least 1 \u03b5. Analyze your algorithm in terms of n and 1/\u03b5.",
        "answer": "We run part a m times, and output YES if and only if all answers output YES. In other words, we amplify the probability of success via repetition.\nOur test works with probability > 1 - ($\\frac{1}{2}$)m. Thus we need\n1 - $\\frac{1}{2}$$\\leq$ \u03b5\n\u21d2 m \u2265 log$\\frac{1}{\u03b5}$.",
        "problem_number": "5(d)",
        "context": "Problem 5. Verifying Polynomial Multiplication.\nThis problem will explore how to check the product of two polynomials. Specifically, we are given three polynomials:\np(x) = anx\u00b2 + an\u22121xn\u22121 + \u00b7\u00b7\u00b7 + ao,\nq(x) = bnxn + bn-1xn-1 + ... + bo,\nr(x) = C2nx2n + C2n\u22121x2n\u22121 + \u00b7\u00b7\u00b7 + Co.\nWe want to check whether p(x) \u00b7 q(x) = r(x) (for all values x). Via FFT, we could simply compute p(x)\u00b7 q(x) and check in O(n log n) time. Instead, we aim to achieve O(n) time via randomization.",
        "custom_id": "5b6cd1sols016"
    },
    {
        "question": "Define TLij to be maximum tastiness value in the top-left quadrant of cell (i, j): TLi,j = max{Ta,b | 1 \u2264 a \u2264 i, 1 \u2264 b \u2264 j}. Find a dynamic programming algorithm to compute TLi,j, for all 1 < i < n and 1 < j < m, in O(nm) time.",
        "answer": "When trying to calculate TLi,j, we see that the maximum can be at cell (i, j). If not, it must lie either in the rectangle from (1, 1) to (i, j \u2013 1), or the rectangle from (1, 1) to (i \u2013 1,j), or both. These three overlapping cases cover our required\nrectangle. We have then,\nTLi,j = max{Ti,j, TLi\u22121,j, TLi,j\u22121}\nFor the base cases, we can just set TL0,j = TL\u00bf,0 = 0 for all valid values of i and j.\nWe can compute the DP value for each state in O(1) time. There are nm states, so our algorithm is O(nm).",
        "problem_number": "6(a)",
        "context": "Problem 6. Dynamic Programming.\nProf. Child is cooking from her garden, which is arranged in grid with n rows and m columns.\nEach cell (i, j) (1 \u2264 i \u2264 n, 1 \u2264 j \u2264 m) has an ingredient growing in it, with tastiness given by a positive value Tij. Prof. Child doesn't like cooking \u201cby the book\u201d. To prepare dinner, she will stand at a cell (i, j) and pick one ingredient from each quadrant relative to that cell. The tastiness of her dish is the product of the tastiness of the four ingredients she chooses. Help Prof. Child find an O(nm) dynamic programming algorithm to maximize the tastiness of her dish.\nHere the four quadrants relative to a cell (i, j) are defined as follows:\ntop-left = {all cells (a, b) | a < i, b < j},\nbottom-left = {all cells (a, b) | a > i, b < j},\ntop-right = {all cells (a, b) | a < i, b > j},\nbottom-right = {all cells (a, b) | a > i, b > j}.\nBecause Prof. Child needs all four quadrants to be non-empty, she can only stand on cells (i, j)\nwhere 1 < i < n and 1 < j < m.",
        "custom_id": "5b6cd1sols017"
    },
    {
        "question": "Use the idea in part (a) to obtain an O(nm) algorithm to find the tastiest dish.",
        "answer": "In part (a) we calculated range maximum for the top-left quadrant. We can similarly define range maximums for the other quadrants. Let BLi,j = max{Ta,b |\ni \u2264 a \u2264 n,1 \u2264 b \u2264 j}, TRi,j = max{Ta,\u044c | 1 \u2264 a \u2264 i,j \u2264 b \u2264 m}, and\nBRi,j = max{Ta,b | i \u2264 a \u2264 n,j \u2264 b \u2264 m}. Each of these can be computed in\nO(nm) time similar to TL.\nTo calculate the tastiest dish Prof. Child can cook when she stands at cell (i, j) (1 <\ni < n and 1 < j < m), we now just need to compute the product TLi\u22121,j\u22121BLi+1,j\u22121 TRi\u22121,j+1BRi+1,j+1\nand pick the maximum product. This can be done in O(nm) time.",
        "problem_number": "6(b)",
        "context": "Problem 6. Dynamic Programming.\nProf. Child is cooking from her garden, which is arranged in grid with n rows and m columns.\nEach cell (i, j) (1 \u2264 i \u2264 n, 1 \u2264 j \u2264 m) has an ingredient growing in it, with tastiness given by a positive value Tij. Prof. Child doesn't like cooking \u201cby the book\u201d. To prepare dinner, she will stand at a cell (i, j) and pick one ingredient from each quadrant relative to that cell. The tastiness of her dish is the product of the tastiness of the four ingredients she chooses. Help Prof. Child find an O(nm) dynamic programming algorithm to maximize the tastiness of her dish.\nHere the four quadrants relative to a cell (i, j) are defined as follows:\ntop-left = {all cells (a, b) | a < i, b < j},\nbottom-left = {all cells (a, b) | a > i, b < j},\ntop-right = {all cells (a, b) | a < i, b > j},\nbottom-right = {all cells (a, b) | a > i, b > j}.\nBecause Prof. Child needs all four quadrants to be non-empty, she can only stand on cells (i, j)\nwhere 1 < i < n and 1 < j < m.",
        "custom_id": "5b6cd1sols018"
    },
    {
        "question": "Give a na\u00efve algorithm running in O(m + n) time.",
        "answer": "Merge the two sorted arrays (which takes O(m + n) time) and find the median using linear-time selection.",
        "problem_number": "7(a)",
        "context": "Problem 7. Median of two sorted arrays.\nFinding the median of a sorted array is easy: return the middle element. But what if you are given two sorted arrays A and B, of size m and n respectively, and you want to find the median of all the numbers in A and B? You may assume that A and B are disjoint.",
        "custom_id": "5b6cd1sols019"
    },
    {
        "question": "If m = n, give an algorithm that runs in O(lgn) time.",
        "answer": "Pick the median m\u2081 for A and median m2 for B. If m\u2081 = m2, return\nm1. If m\u2081 > m2, remove the second half of A and the first half of B. Then we get\ntwo subarrays with size n/2. Repeat until both arrays are smaller than a constant.\nm1 < m2 is symmetric.",
        "problem_number": "7(b)",
        "context": "Problem 7. Median of two sorted arrays.\nFinding the median of a sorted array is easy: return the middle element. But what if you are given two sorted arrays A and B, of size m and n respectively, and you want to find the median of all the numbers in A and B? You may assume that A and B are disjoint.",
        "custom_id": "5b6cd1sols020"
    },
    {
        "question": "Give an algorithm that runs in O(lg(min{m, n})) time, for any m and n.",
        "answer": "Without loss of generality, assume |A| = m > n = |B|. We can safely remove elements A[0 : m-n/2] and A[m+n/2 : m 1] because none of these elements can\nbe the median of A + B. After this process, we get two arrays of size approximately\nn. Then we can run part (b). The complexity is O(lg(min(m, n)))",
        "problem_number": "7(c)",
        "context": "Problem 7. Median of two sorted arrays.\nFinding the median of a sorted array is easy: return the middle element. But what if you are given two sorted arrays A and B, of size m and n respectively, and you want to find the median of all the numbers in A and B? You may assume that A and B are disjoint.",
        "custom_id": "5b6cd1sols021"
    },
    {
        "question": "Suppose algorithm A has two steps, and A succeeds if both the steps succeed. If the two steps succeed with probability $p_1$ and $p_2$ respectively, then A succeeds with probability $p_1p_2$.",
        "answer": "False. Unless the two steps are independent.",
        "problem_number": "1a",
        "context": "True or False. [4 points]",
        "custom_id": "c212dlsols000"
    },
    {
        "question": "If the divide-and-conquer convex hull algorithm (from Lecture 2) used a $\\Theta(n^2)$ strategy to discover the maximum and minimum tangents, the overall algorithm would run in $O(n^2 \\log n)$ time.",
        "answer": "False. The recurrence would be $T(n) = 2T(\\frac{n}{2}) + \\Theta(n^2)$ whose solution is $T(n) = \\Theta(n^2)$.",
        "problem_number": "1b",
        "context": "True or False. [4 points]",
        "custom_id": "c212dlsols001"
    },
    {
        "question": "In order to get an expected O(n log n) runtime for \u201cparanoid\" quicksort (from Lecture 3), we require the recursive divide step to split the array into two subarrays each of at least $\\frac{1}{4}$ the size of the original array.",
        "answer": "False. As long as it is a constant fraction of the original array, we can get the bound.",
        "problem_number": "1c",
        "context": "True or False. [4 points]",
        "custom_id": "c212dlsols002"
    },
    {
        "question": "A binary min-heap with n elements supports INSERT in O(log n) amortized time and DELETE-MIN in 0 amortized time.",
        "answer": "True. Same amortization as in class for insert/delete in 2-3 trees.",
        "problem_number": "1d",
        "context": "True or False. [4 points]",
        "custom_id": "c212dlsols003"
    },
    {
        "question": "The hash family H = {$h_1, h_2$} is universal, where $h_1, h_2 : $ {1, 2, 3} $\\rightarrow$ {0, 1} are defined by the following table:\n\n(For example, $h_1(3) = 0.$)",
        "answer": "False. Consider elements 1 and 3: $h_1$ and $h_2$ both cause a collision between them, so in particular a uniformly random hash function chosen from H causes a collision between 1 and 3 with probability 1, greater than the 1/2 allowed for universal hashing (since there are 2 hash buckets).",
        "problem_number": "1e",
        "context": "True or False. [4 points]",
        "custom_id": "c212dlsols004"
    },
    {
        "question": "Recall the $O(n^3 lg n)$ matrix-multiplication algorithm to compute shortest paths, where we replaced the matrix-multiplication operator pair (*, +) with (+, min). If we instead replace the operator pair with (+, *), then we compute the product of the weights of all paths between each pair of vertices.",
        "answer": "False. If the graph has a cycle, there are infinitely many paths between some pairs of vertices, so the product ought to be $\\pm \\infty$, yet the matrix-multiplication algorithm will compute finite values if the original matrix has all finite values (e.g., a clique).",
        "problem_number": "1f",
        "context": "True or False. [4 points]",
        "custom_id": "c212dlsols005"
    },
    {
        "question": "Negating all the edge weights in a weighted undirected graph G and then finding the minimum spanning tree gives us the maximum-weight spanning tree of the original graph G.",
        "answer": "True.",
        "problem_number": "1g",
        "context": "True or False. [4 points]",
        "custom_id": "c212dlsols006"
    },
    {
        "question": "In a graph with unique edge weights, the spanning tree of second-lowest weight is unique.",
        "answer": "False, can construct counter-example.",
        "problem_number": "1h",
        "context": "True or False. [4 points]",
        "custom_id": "c212dlsols007"
    },
    {
        "question": "In the recursion of the Floyd-Warshall algorithm:\n\n$d_{uv}^{(k)} = min \\{ d_{uv}^{(k-1)}, d_{uk}^{(k-1)} + d_{kv}^{(k-1)} \\}$,\n\n$d_{uv}^{(k)}$ represents the length of the shortest path from vertex u to vertex v that contains at most k edges.",
        "answer": "False. $d_{uv}^{(k)}$ is the length of the shortest path from vertex u to vertex v that only uses vertex {1, 2, ... k} as intermediate nodes.",
        "problem_number": "1i",
        "context": "True or False. [4 points]",
        "custom_id": "c212dlsols008"
    },
    {
        "question": "Consider a network of processes based on an arbitrary undirected graph G = (V, E) with a distinguished vertex $v_0 \\in V$. The process at each vertex $v \\in V$ starts with a positive integer $x_v$. The goal is for the process at $v_0$ to compute the maximum $max_{v \\in V} x_v$. There is an asynchronous distributed algorithm that solves this problem using $O(diam^2d)$ time and $O(|E| + diam \\cdot n)$ messages.",
        "answer": "True.\nUsing the algorithm from Problem 10-2, we can construct a BFS tree rooted at $v_0$ within the given time and message bounds. The root process can broadcast a signal telling all the processes that the tree is completed. Then the processes can use the tree for convergecasting their values, computing the max as the messages move up the tree. The broadcast and convergecast phases do not exceed the bounds for the BFS construction.",
        "problem_number": "1j",
        "context": "True or False. [4 points]",
        "custom_id": "c212dlsols009"
    },
    {
        "question": "Suppose a file server stores a hash of every file in addition to the file contents. When you download a file from the server, you also download the hash and confirm that it matches the file. This system securely verifies that the downloaded file has not been modified by an adversary, provided the hash function has collision resistance.",
        "answer": "False. This scheme is not secure because the adversary can simply replace the file with any file and the hash of that file, and you cannot tell the difference.",
        "problem_number": "1k",
        "context": "True or False. [4 points]",
        "custom_id": "c212dlsols010"
    },
    {
        "question": "Suppose Alice, Bob, and Charlie secretly generate a, b and c, respectively, and publish $g^a \\mod p, g^b \\mod p$, and $g^c \\mod p$, where p is a prime. Then, Alice, Bob, and Charles can each compute $g^{abc} \\mod p$ as a shared secret known only to the three of them.",
        "answer": "False. For example, Alice only knows a, $g^b$ and $g^c$, so she can compute $g^{ab}$ and $g^{ac}$ but not $g^{abc}$.",
        "problem_number": "1l",
        "context": "True or False. [4 points]",
        "custom_id": "c212dlsols011"
    },
    {
        "question": "The number of memory transfers used by the best cache-oblivious algorithm is always at least the number of memory transfers used by the best external-memory algorithm for the same problem.",
        "answer": "True. Make implicit memory transfers explicit, using LRU.",
        "problem_number": "1m",
        "context": "True or False. [4 points]",
        "custom_id": "c212dlsols012"
    },
    {
        "question": "If there is a time-optimal divide-and-conquer algorithm for a problem, then that algorithm is also optimal with respect to memory transfers in the cache-oblivious model.",
        "answer": "False. Example: binary search.",
        "problem_number": "1n",
        "context": "True or False. [4 points]",
        "custom_id": "c212dlsols013"
    },
    {
        "question": "What extra information needs to be stored at each node? Describe how to answer an AVERAGE(x) query in $O(lg n)$ time using this extra information.",
        "answer": "Each node x should store x. size \u2014 the size of the subtree rooted at x \u2014 and x.sum \u2014 the sum of all the key values in the subtree rooted at x. For a value\nx > 0, let $S_x$ be the set of all keys less than or equal to x. Let $A_x$ and $B_x$ be the sum\nand the size of $S_x$.\nWe can compute $A_x$ as follows. Let u be the leaf with smallest key larger than x.\nFinding u from the root only takes O(lgn) time by using SEARCH in a 2-3 tree. Now\nconsider the path from the root of the tree to u. Clearly, $A_x$ is the sum of all leaves\nthat are on the left of this path. Therefore, $A_x$ can be computed by summing up all\ny. sum's for every node y that is a left sibling of a node in the path. Since there are\nonly lg n such nodes y's, computing $A_x$ only takes O(lg n) time.\nComputing $B_x$ is similar: instead of summing up y. sum, we sum up y.size. There-\nfore, it also takes O(lg n) time to compute $B_x$.\nTherefore, AVERAGE(x) which is $\\frac{A_x}{B_x}$ can be answered in O(lg n)) time.",
        "problem_number": "3a",
        "context": "You are in charge of the salary database for Meancorp, which stores all employee salaries in a 2-3 tree ordered by salary. Meancorp compiles regular reports to the Department of Fairness about the salary for low-income employees in the firm. You are asked to implement a new database operation AVERAGE(x) which returns the average salary of all employees whose salary is at most x.",
        "custom_id": "c212dlsols014"
    },
    {
        "question": "Describe how to modify INSERT to maintain this information. Briefly justify that the worst-case running time for INSERT remains O(lgn).",
        "answer": "Maintaining x. size is similar to what was covered in recitation and home-\nwork. Maintaining x. sum is exactly the same: when a node x gets inserted, we simply\nincrease y.sum for every ancestor y of x by the amount x.key. When a node splits,\nwe recompute the x.sum attribute for the split nodes and its parent. Hence, INSERT\nstill runs in worst-case time O(lgn).",
        "problem_number": "3b",
        "context": "You are in charge of the salary database for Meancorp, which stores all employee salaries in a 2-3 tree ordered by salary. Meancorp compiles regular reports to the Department of Fairness about the salary for low-income employees in the firm. You are asked to implement a new database operation AVERAGE(x) which returns the average salary of all employees whose salary is at most x.",
        "custom_id": "c212dlsols015"
    },
    {
        "question": "Suppose we send Forrest k reminders for each of n events. What is the expected number of appointments Forrest will remember? Give your answer in terms of k and n.",
        "answer": "These are all independent events. So linearity of expectation applies.\nEach given event has been remembered with probability $1 - 2^{-k}$. So in expectation\nn(1 - $2^{-k}$) appointments are remembered.",
        "problem_number": "4a",
        "context": "Prof. Forrest Gump is very forgetful, so he uses automatic calendar reminders for his appointments. For each reminder he receives for an event, he has a 50% chance of actually remembering the event (decided by an independent coin flip).",
        "custom_id": "c212dlsols016"
    },
    {
        "question": "Suppose we send Forrest k reminders for a single event. How should we set k with respect to n so that Forrest will remember the event with high probability, i.e., 1 \u2013 1/n\u00ba?",
        "answer": "This problem is equivalent to how many times we must flip a coin to get a\nhead with high probability. The probability of k tails in a row is $1/2^k$. Thus exactly\n$\\alpha lg n$ coin flips suffice.",
        "problem_number": "4b",
        "context": "Prof. Forrest Gump is very forgetful, so he uses automatic calendar reminders for his appointments. For each reminder he receives for an event, he has a 50% chance of actually remembering the event (decided by an independent coin flip).",
        "custom_id": "c212dlsols017"
    },
    {
        "question": "Suppose we send Forrest k reminders for each of n events. How should we set k with respect to n so that Forrest will remember all the events with high probability, i.e., 1 \u2013 1/n\u00ba?",
        "answer": "We must send at least k = $\\Omega(lg n)$ reminders, because we needed this\nmany reminders to remember one event with high probability.\nIf we send k = (a + 1) lg n reminders, then each event is remembered with proba-\nbility 1 - $1/n^{\\alpha + 1}$. By a union bound, we know that all events are remembered with\nprobability 1 - $1/n^{\\alpha}$. So, the number of reminders needed is k = $O(lg n)$.",
        "problem_number": "4c",
        "context": "Prof. Forrest Gump is very forgetful, so he uses automatic calendar reminders for his appointments. For each reminder he receives for an event, he has a 50% chance of actually remembering the event (decided by an independent coin flip).",
        "custom_id": "c212dlsols018"
    },
    {
        "question": "Assume that Prof. Chopin decides to learn exactly k pieces. Prove that he needs to consider only the k lowest $p_i$s and the k highest $t_j$s.",
        "answer": "Assume there exists a selection of teachers and pieces for learning k pieces.\nLet the set of lowest k pieces be $P_k$. If there is a piece in our selection that is $\\notin P_k$,\nthen we must have a piece in $P_k$ not in the final selection. If we swap the one with\nthe higher cost ($\\notin P_k$) with the one with lower cost ($\\in P_k$), the new selection thus\nmade will still be valid, because if the higher time cost was fulfilled in the previous\nselection, the lower time cost in the new selection will still be fulfilled. In this way,\nwe can swap pieces until all of them are $\\in P_k$.\nSimilarly, we can swap the teachers for those of higher value until they are the ones\nwith the k highest times.",
        "problem_number": "5a",
        "context": "Prof. Chopin has a piano recital coming up, and in preparation, he wants to learn as many pieces as possible. There are m possible pieces he could learn. Each piece i takes p\u2081 hours to learn.\nProf. Chopin has a total of T hours that he can study by himself (before getting bored). In addition, he has n piano teachers. Each teacher j will spend up to t; hours teaching. The teachers are very strict, so they will teach Prof. Chopin only a single piece, and only if no other teacher is teaching him that piece.\nThus, to learn piece i, Prof. Chopin can either (1) learn it by himself by spending p\u2081 of his T self-learning budget; or (2) he can choose a unique teacher j (not chosen for any other piece), learn together for min{$p_i, t_j$} hours, and if any hours remain ($p_i > t_j$), learn the rest using $p_i - t_j$ hours of his T self-learning budget. (Learning part of a piece is useless.)",
        "custom_id": "c212dlsols019"
    },
    {
        "question": "Assuming part (a), give an efficient greedy algorithm to determine whether Prof. Chopin can learn exactly k pieces. Argue its correctness.",
        "answer": "Let us sort all the teachers and pieces in increasing order beforehand. Call the sorted lists P and T. We see that if a solution exists, there is also one in which P\u2081\nis paired with $T_{n\u2212k+1}$, $P_2$ is paired with $T_{n\u2212k+2}$ and so on.\nSo for each 1 \u2264 i \u2264 k, the greedy algorithm checks if $P_i < T_{n-k+i}$. If it is, then we\ndon't need to use the shared time for this piece. If it is not, we need to use $T_{n-k+i} - P_i$\nof the shared time. We can add up these values. In the end, if the total shared time we\nneed is > T, we return false. Otherwise, we return true.\nThis takes O(k) time, apart from the initial sorting.",
        "problem_number": "5b",
        "context": "Prof. Chopin has a piano recital coming up, and in preparation, he wants to learn as many pieces as possible. There are m possible pieces he could learn. Each piece i takes p\u2081 hours to learn.\nProf. Chopin has a total of T hours that he can study by himself (before getting bored). In addition, he has n piano teachers. Each teacher j will spend up to t; hours teaching. The teachers are very strict, so they will teach Prof. Chopin only a single piece, and only if no other teacher is teaching him that piece.\nThus, to learn piece i, Prof. Chopin can either (1) learn it by himself by spending p\u2081 of his T self-learning budget; or (2) he can choose a unique teacher j (not chosen for any other piece), learn together for min{$p_i, t_j$} hours, and if any hours remain ($p_i > t_j$), learn the rest using $p_i - t_j$ hours of his T self-learning budget. (Learning part of a piece is useless.)",
        "custom_id": "c212dlsols020"
    },
    {
        "question": "Using part (b) as a black box, give an efficient algorithm that finds the maximum number of pieces Prof. Chopin can learn. Analyze its running time.",
        "answer": "Notice that if $k_{max}$ is the maximum value of pieces we can learn, we can\nalso learn k pieces for any k \u2264 $k_{max}$. This suggests that we binary search over the\nvalue of k.\nWe try O(log n) values during the binary search, and checking each value takes O(n)\ntime. This takes O(n log n) time. The sorting also took O(n log n) time, so the algo-\nrithm takes O(n log n) time overall.",
        "problem_number": "5c",
        "context": "Prof. Chopin has a piano recital coming up, and in preparation, he wants to learn as many pieces as possible. There are m possible pieces he could learn. Each piece i takes p\u2081 hours to learn.\nProf. Chopin has a total of T hours that he can study by himself (before getting bored). In addition, he has n piano teachers. Each teacher j will spend up to t; hours teaching. The teachers are very strict, so they will teach Prof. Chopin only a single piece, and only if no other teacher is teaching him that piece.\nThus, to learn piece i, Prof. Chopin can either (1) learn it by himself by spending p\u2081 of his T self-learning budget; or (2) he can choose a unique teacher j (not chosen for any other piece), learn together for min{$p_i, t_j$} hours, and if any hours remain ($p_i > t_j$), learn the rest using $p_i - t_j$ hours of his T self-learning budget. (Learning part of a piece is useless.)",
        "custom_id": "c212dlsols021"
    },
    {
        "question": "Draw the residual graph $G_f$ of G with respect to f.",
        "answer": "",
        "problem_number": "6a",
        "context": "Consider the following flow network and initial flow f. We will perform one iteration of the\nEdmonds-Karp algorithm.",
        "custom_id": "c212dlsols022"
    },
    {
        "question": "List the vertices in the shortest augmenting path, that is, the augmenting path with the fewest possible edges.",
        "answer": "s\u21923\u21922\u21925\u2192t\nor\ns\u21923\u21922\u21926\u2192t",
        "problem_number": "6b",
        "context": "Consider the following flow network and initial flow f. We will perform one iteration of the\nEdmonds-Karp algorithm.",
        "custom_id": "c212dlsols023"
    },
    {
        "question": "Perform the augmentation. What is the value of the resulting flow?",
        "answer": "26. The augmenting flow has value 1.",
        "problem_number": "6c",
        "context": "Consider the following flow network and initial flow f. We will perform one iteration of the\nEdmonds-Karp algorithm.",
        "custom_id": "c212dlsols024"
    },
    {
        "question": "Give a straightforward algorithm that checks whether any subset of k projects can be completed to solve the decisional problem. Analyze its time complexity in terms of m, n, and k.",
        "answer": "For each (2) subsets of k projects, check whether any employee is required\nby more than one project. This can be done simply by going each of the k projects p,\nmarking the employees in $E_p$ as needed, and if any employee is marked twice, then\nthis subset fails. Output \"yes\" if any subset of k project can be completed, and \u201cno\u201d\notherwise.\nThe time complexity is (1) m because there are (2) subsets of size k and we pay O(m)\ntime per subset (because all but one employee will be marked only once). Asymptoti-\ncally, this is $(n/k)^k m$.",
        "problem_number": "7a",
        "context": "For your new startup company, Uber for Algorithms, you are trying to assign projects to employees.\nYou have a set P of n projects and a set E of m employees. Each employee e can only work on one project, and each project p \u2208 P has a subset Ep \u2286 E of employees that must be assigned to p\nto complete p. The decision problem we want to solve is whether we can assign the employees to\nprojects such that we can complete (at least) k projects.",
        "custom_id": "c212dlsols025"
    },
    {
        "question": "Is your algorithm in part (a) fixed-parameter tractable? Briefly explain.",
        "answer": "No. An FPT algorithms requires a time complexity of $n^{o(1)} f(k)$. By con-\ntrast, in our running time, the exponent on n increases with k.",
        "problem_number": "7b",
        "context": "For your new startup company, Uber for Algorithms, you are trying to assign projects to employees.\nYou have a set P of n projects and a set E of m employees. Each employee e can only work on one project, and each project p \u2208 P has a subset Ep \u2286 E of employees that must be assigned to p\nto complete p. The decision problem we want to solve is whether we can assign the employees to\nprojects such that we can complete (at least) k projects.",
        "custom_id": "c212dlsols026"
    },
    {
        "question": "Show that the problem is NP-hard via a reduction from 3D matching.\nRecall the 3D matching problem: You are given three sets X, Y, Z, each of size m;\na set T \u2286 X \u00d7 Y \u00d7 Z of triples; and an integer k. The goal is to determine whether\nthere is a subset S \u2286 T of (at least) k disjoint triples.",
        "answer": "Each (x, y, z) \u2208 T becomes a project that requires employees $E_{(x,y,z)} =$\n{$e_x, e_y, e_z$}. Thus n = |T|, E = X U Y U Z, and m = |X| + |Y|+|Z|. We set k to be\nthe same in both problems. The size of the matching is equal to the number of projects\nthat can be completed because both problems model disjointness: if k projects can be\ncompleted, a subset S of size k can be found, and vice versa. The reduction takes\npolynomial time.",
        "problem_number": "7c",
        "context": "For your new startup company, Uber for Algorithms, you are trying to assign projects to employees.\nYou have a set P of n projects and a set E of m employees. Each employee e can only work on one project, and each project p \u2208 P has a subset Ep \u2286 E of employees that must be assigned to p\nto complete p. The decision problem we want to solve is whether we can assign the employees to\nprojects such that we can complete (at least) k projects.",
        "custom_id": "c212dlsols027"
    },
    {
        "question": "Describe a greedy approximation algorithm for this problem.",
        "answer": "Let Jj to be the set of jobs that Mj will run, and Tj to be the total time it\nmachine Mj is busy (i.e., $T_j = \\sum_{i\\in J_j} t_i$). Initially, $J_j = \\emptyset$, and $T_j = 0$ for all j.\nFor i = 1, . . ., n, assign job i to machine Mj such that $T_j = min_{1<k<m}(T_k)$. That is,\n$J_j = J_j U i$ and $T_j = T_j + t_i$. Output $J_j$'s.\nThis runs in O(nlgm) time by keeping a min-heap of the machines based on the\ncurrent total runtime of each machine.",
        "problem_number": "8a",
        "context": "Suppose you need to complete n jobs, and the time it takes to complete job i is $t_i$. You are\ngiven m identical machines M1, M2, ..., Mm to run the jobs on. Each machine can run only one\njob at a time, and each job must be completely run on a single machine. If you assign a set\n$J_j \\subseteq \\{1, 2, ..., n\\}$ of jobs to machine M\u00a1, then it will need $T\u2081 = \\sum_{i\\in J_j} t_i$ time. Your goal is to\npartition the n jobs among the m machines to minimize $max_i T_i$.",
        "custom_id": "c212dlsols028"
    },
    {
        "question": "Show that your algorithm from part (a) is a 2-approximation algorithm.",
        "answer": "A lower bound to the optimal is L = max(= $\\frac{1}{m}\\sum_{1<i<n} t_i$, $max_i(t_i)$) since the\nbest you can do is to evenly divide the fractional jobs, and it has to run for at least as\nlong as the longest job.\nNow let $M_e$ be the machine that runs for the longest, and let $i^*$ be the last job that was\nassigned to $M_e$ using the greedy algorithm. Let $T_l^*$ be the total run time of all jobs of\n$M_j$ immediately before assigning $i^*$; $T_l^* = min_j T_j^*$. Then we have\n$m\\cdot T_l \\leq \\sum T_l^* = \\sum t_i \\leq \\sum t_i m \\cdot L$\nwhich implies that $T_l^* < L$. Putting it together, we have $T_l = T_l^* + t_{i^*} \\leq L + t_{i^*} \\leq 2L \\leq 2OPT$. Therefore, this is a 2-approximation algorithm.",
        "problem_number": "8b",
        "context": "Suppose you need to complete n jobs, and the time it takes to complete job i is $t_i$. You are\ngiven m identical machines M1, M2, ..., Mm to run the jobs on. Each machine can run only one\njob at a time, and each job must be completely run on a single machine. If you assign a set\n$J_j \\subseteq \\{1, 2, ..., n\\}$ of jobs to machine M\u00a1, then it will need $T\u2081 = \\sum_{i\\in J_j} t_i$ time. Your goal is to\npartition the n jobs among the m machines to minimize $max_i T_i$.",
        "custom_id": "c212dlsols029"
    },
    {
        "question": "Let S be any maximal independent set of G' (i.e., adding any other vertex to\nS would violate independence). Prove that, for each vertex v \u2208 V, S contains exactly\none of the \u2206 + 1 vertices in V' of the form (v, i). Hint: Use the Pigeonhole Principle.",
        "answer": "It cannot contain more than one, since all of these are connected in G' and\nthat would violate independence.\nNow suppose for contradiction that, for some particular u, S contains no vertices of\nthe form (u, i). Then by maximality, every vertex of the form (u, i) must have some\nG'-neighbor in S. Since that neighbor is not of the form (u, *), it must be of the form\n(v, i), for some v with (u, v) \u2208 E.\nThus, each of the \u25b3+1 vertices of the form (u, i) has some neighbor of the form (v, i)\nin S, where (u,v) \u2208 E. Since u has at most A neighbors in G, by the Pigeonhole\nPrinciple, there must be two different values of i, say i\u2081 and 12, for which there is a\nsingle v such that (u, i\u2081) is a G'-neighbor of (v, i\u2081), (u, i\u2082) is a G'-neighbor of (v, i\u2082),\nand both (v, i\u2081) and (v, i2) are in S. That is a contradiction because S can contain at\nmost one vertex of the form (v, *).",
        "problem_number": "9a",
        "context": "Consider an undirected graph G = (V, E) in which every vertex has degree at most \u2206. Define a\nnew graph G' = (V', E'), the Cartesian product of G with a clique of size \u25b3 + 1. Specifically, V'\nis the set of pairs (v, i) for all vertices v \u2208 V and integers i with 0 \u2264 i \u2264 \u2206, and E' consists of\ntwo types of edges:",
        "custom_id": "c212dlsols030"
    },
    {
        "question": "Now consider a synchronous network of processes based on the graph G, where every vertex knows an upper bound \u2206 on the degree. Give a distributed algorithm to find a vertex (\u2206 + 1)-coloring of G, i.e., a mapping from vertices in V to colors in {0, 1, . . . , \u2206} such that adjacent vertices have distinct colors. The process associated with each vertex should output its color. Argue correctness.",
        "answer": "The \u201ccolors\u201d will be chosen from {0, 1, . . . , \u2206}.\nThe nodes of G simulate an MIS algorithm for G'. Specifically, the node associated\nwith vertex u of G simulates the \u2206 + 1 nodes associated with vertices of the form\n(u, i) of G'. The algorithm produces an MIS S for G', where each node of G learns\nwhich of its simulated nodes correspond to vertices in S. By Part (a), for each vertex u\nof G, there is a unique color i such that (u, i) \u2208 S; the node associated with u chooses\nthis color i.\nObviously, this strategy uses at most \u2206 + 1 colors. To see that no two neighbors in G\nare colored with the same color, suppose for contradiction that neighbors u and v are\ncolored with the same color, say i. That means that both (u, i) and (v, i) are in S. But\n(u, i) and (v, i) are neighbors in G', contradicting the independence property for S.",
        "problem_number": "9b",
        "context": "Consider an undirected graph G = (V, E) in which every vertex has degree at most \u2206. Define a\nnew graph G' = (V', E'), the Cartesian product of G with a clique of size \u25b3 + 1. Specifically, V'\nis the set of pairs (v, i) for all vertices v \u2208 V and integers i with 0 \u2264 i \u2264 \u2206, and E' consists of\ntwo types of edges:",
        "custom_id": "c212dlsols031"
    },
    {
        "question": "Analyze the expected time and communication costs for solving the coloring problem in this way, including the cost of Luby's algorithm.",
        "answer": "The costs are just those of solving MIS on G'; the final decisions are local\nand don't require any extra rounds.\nTime (number of rounds): The expected time to solve MIS on G' is O(lg (n\u00b7 \u2206)),\nbecause the number of nodes in G' is n\u00b7 (\u2206 + 1). The O(lg (n\u00b7 \u2206)) bound can be\nsimplified to O(lgn).\nCommunication (number of messages): The expected number of messages is O(Elg n),\ncorresponding to O(lg n) rounds and messages on all edges (in both directions) at each\nround.",
        "problem_number": "9c",
        "context": "Consider an undirected graph G = (V, E) in which every vertex has degree at most \u2206. Define a\nnew graph G' = (V', E'), the Cartesian product of G with a clique of size \u25b3 + 1. Specifically, V'\nis the set of pairs (v, i) for all vertices v \u2208 V and integers i with 0 \u2264 i \u2264 \u2206, and E' consists of\ntwo types of edges:",
        "custom_id": "c212dlsols032"
    }
]
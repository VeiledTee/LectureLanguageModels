{
    "questions": [
        {
            "question": "Given an n \u00d7 m array representing an image, describe an O(nm)-time algorithm to count the number of blobs in the image.",
            "answer": "Construct a graph G with a vertex per white pixel, with an undirected edge between two vertices if the pixels associated with them are both white and share an edge of the grid. This graph has size at most O(nm) vertices and at most O(nm) edges (as pixels share edges with at most four other pixels), so can be constructed in O(nm) time. Each connected component of this graph corresponds to a blob, so run Full-BFS or Full-DFS to count the number of connected components in G in O(nm) time.",
            "problem_number": "1",
            "context": "An image is a 2D grid of black and white square pixels where each white pixel is contained in a blob. Two white pixels are in the same blob if they share an edge of the grid. Black pixels are not contained in blobs."
        },
        {
            "question": "Given a connected undirected graph G = (V, E) with strictly positive weights w : E \u2192 Z+ where |E| = |V|, describe an O(|V|)-time algorithm to determine a path from vertex s to vertex t of minimum weight.",
            "answer": "Given two vertices in a weighted tree containing only positive weight edges, there is a unique simple path between them which is also the minimum weight path. A depth-first search from any source vertex s in the tree results in a directed DFS tree in O(|V|) time (since |E| = |V| \u2013 1). Then relaxing edges in topological sort order of the directed DFS tree computes minimum weight paths from s in O(|V|) time. Since G has one cycle, our strategy will be to break the cycle by removing an edge, and then compute the minimum weight path from s to t in the resultant tree.\nFirst, we find the vertex v closest to s on the cycle by running depth-first search from s in O(|V|) time (since |E| = |V|). One edge e\u2081 of the cycle will not be in the tree returned by DFS (a back edge to v), with the other edge of the cycle incident to v being a single outgoing DFS tree edge 62. If s is on the cycle, v = s; otherwise the unique path from s to v does not contain e1 or e2.\nA shortest path from s to t cannot traverse both edges e\u2081 and e2, or else the path would visit v at least twice, traversing a cycle of positive weight. Removing either e1 or e2 results in a tree, at least one of which contains the minimum weight path from s to t. Thus, find the minimum weight path from s to t in each tree using the algorithm described above, returning the minimum of the two in O(|V|) time.",
            "problem_number": "2",
            "context": ""
        },
        {
            "question": "Describe an O(nlog n)-time algorithm to find the shortest driving route from the power plant back home that avoids driving within driving distance k of a doughnut shop (or determine no such route exists).",
            "answer": "Construct a graph G with a vertex for each of the n city locations, and an undirected edge between two locations if there is a road connecting them, with each edge weighted by the positive length of its corresponding road. The degree of each vertex is bounded by a constant (i.e., 5), so the number of edges in G is O(n). First, we identify vertices that are within driving distance k of a doughnut shop location: create an auxiliary vertex x with a 0-weight outgoing edge from x to every doughnut shop location, and run Dijkstra from x. Remove every vertex from the graph whose shortest path from x is less than or equal to k, resulting in graph G' \u2282 G. If either p or h are not in G', then no route exists. Otherwise, run Dijkstra from p in G'. If no path exists to h, then no valid route exists. Otherwise, Dijkstra finds a shortest path from p to h, so return it (via parent pointers). This algorithm runs Dijkstra twice. Since the size of either graph is O(|V|), Dijkstra runs in O(|V| log |V|) = O(nlog n) time (e.g. using a binary heap to implement a priority queue).",
            "problem_number": "3",
            "context": "Momer has just finished work at the FingSprield power plant at location p, and needs to drive to his home at location h. But along the way, if his driving route ever comes within driving distance k of a doughnut shop, he will stop and eat doughnuts, and his wife, Harge, will be angry. Momer knows the layout of FingSprield, which can be modeled as a set of n locations, with two-way roads of known driving distance connecting some pairs of locations (you may assume that no location is incident to more than five roads), as well as the locations of the d doughnut shops in the city."
        },
        {
            "question": "Given directed graph G = (V, E) having arbitrary edge weights w : E \u2192 Z and two vertices s, t \u2208 V, describe an O(|V|\u00b3)-time algorithm to find the minimum weight of any path from s to t containing at least |V| edges.",
            "answer": "Our strategy will compute intermediate values for each vertex v \u2208 V:\n1. the minimum weight w\u2081 (v) of any path from s to v using exactly |V| edges, and then\n2. the minimum weight w\u2082(v) of any path from v to t using any number of edges.\nFirst, to compute (1), we make a duplicated graph similar to Bellman-Ford, but without edges corresponding to remaining at a vertex. Specifically, construct a graph G\u2081 with\n\u2022 |V| + 1 vertices for each vertex v \u2208 V: vertex vk for k \u2208 {0, . . ., |V|} representing reaching v from s along a path containing k edges; and\n\u2022 |V| edges for each edge (u, v) \u2208 E: edge (uk\u22121, Uk) of the same weight for k \u2208 {1, ...,|V|}.\nNow a path in G\u2081 from so to \u03c5\u03bd for any v \u2208 V corresponds to a path from s to v in G through exactly |V| edges. So solve SSSPs in G\u2081 from so to compute the minimum weight of paths to each vertex traversing exactly |V| edges. This graph is acyclic, and has size O(|V|(|V| + |E|)) =\nO(|V|\u00b3), so we can solve SSSP on G\u2081 via DAG relaxation in O(|V|\u00b3) time.\nSecond, to compute (2), we make a new graph G2 from G where every edge is reversed. Then every path to t in G corresponds to a path in G2 from t, so compute SSSPs from t in G2 to find the minimum weight of any path from v to t in G using any number of edges, which can be done in O(|V||E|) = O(|V|\u00b3) time using Bellman-Ford.\nOnce computed, finding the minimum sum of w\u2081(v) + w\u2082(v) over all vertices v \u2208 V will provide the minimum weight of any path from s to t containing at least |V| edges, since every such path can be decomposed into its first |V| edges and then the remainder. This loop takes O(|V|) time, so the algorithm runs in O(|V|\u00b3) time in total.",
            "problem_number": "4",
            "context": ""
        }
    ]
}
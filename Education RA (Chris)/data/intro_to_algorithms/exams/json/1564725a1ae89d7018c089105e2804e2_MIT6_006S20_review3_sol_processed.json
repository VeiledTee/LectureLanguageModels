{
    "questions": [
        {
            "question": "Describe a O(n)-time algorithm to determine the maximum amount of lottery winnings Tiff can win in the next n days by playing the lottery infrequently.",
            "answer": "1. Subproblems  \n• Let L(i) be the cash payout of playing the lottery on day i ∈ {1,...,n}  \n• Need to keep track of most recent two plays (or equivalently, restrictions on future plays)  \n• x(i, j): maximum lottery winnings playing on suffix of days from i to n,  \n  assuming play on day i and next allowable play is on day i + j  \n• for i ∈ {1,...,n} and j ∈ {1,..., 6}  \n\n2. Relate  \n• Tiffany will play again on some day in future. Guess!  \n• It is never optimal to go 11 days without playing the lottery, as playing on the 6th day  \n  would be valid and strictly increase winnings  \n• The next play can be on day i + k for k ∈ {j, ... , 11}  \n• If next play on i + k for k ∈ {1,..., 6}, next allowable play is on day i + 7  \n• If next play on i + k for k ∈ {7,..., 11}, next allowable play is on day i + k + 1  \n• x(i, j) = L(i) + max{x(i + k, max{1, 7 − k}) | k ∈ {i, ... , 11} and i + k ≤ n}  \n\n3. Topo  \n• Subproblems x(i, j) only depend on strictly larger i, so acyclic  \n\n4. Base  \n• x(n, j) = L(i) for all j ∈ {1,..., 6}  \n\n5. Original  \n• Solve subproblems via recursive top-down or iterative bottom-up  \n• Guess first play (within first seven days)  \n• Solution to original problem is max{x(i, 1) | i ∈ {1,..., 7}}  \n• (Can store parent pointers to reconstruct days played)  \n\n6. Time  \n• # subproblems: 6n  \n• work per subproblem: O(1)  \n• work for original: O(1)  \n• O(n) running time  \n",
            "problem_number": "1",
            "context": "Tiffany Bannen stumbles upon a lottery chart dropped by a time traveler from the future, which lists winning lottery numbers and positive integer cash payouts for the next n days. Tiffany wants to use this information to make money, but is worried if she plays winning numbers every day, lottery organizers will get suspicious. As such, she decides to play the lottery infrequently: at most twice in any seven day period."
        },
        {
            "question": "Describe an O(n^4)-time algorithm to determine whether Charlie is a fraud.",
            "answer": "1. Subproblems  \n• Let A, B, and C be the relevant length-n DNA sequences from Alice, Bob, and Charlie.  \n• Want to match some characters of A and B to all characters of C.  \n• x(i, j, ki, kj): true if a length-ki subsequence of suffix A[i:] and a length-kj subsequence of prefix B[j:]  \n  can match all characters in suffix C[(n − ki − kj):] (the suffix containing the last ki + kj characters),  \n  and false otherwise.  \n• Defined for i, j ∈ {0,...,n} and ki, kj ∈ {0,...,n/2} (assume n is even).  \n\n2. Relate  \n• Must match character C[i]; if A[i] = C[i] or B[i] = C[i], recurse on remainder.  \n• Alternatively, do not use either A[i] or B[i].  \n• The recurrence relation:  \n\nx(i, j, ki, kj) = OR { x(i + 1, j, ki + 1, kj) if A[i] = C[n − ki − kj] and ki > 0, x(i, j + 1, ki, kj + 1) if B[j] = C[n − ki − kj] and kj > 0, x(i + 1, j, ki, kj) if i < n, x(i, j + 1, ki, kj) if j < n }\n\n3. Topo  \n• Subproblem x(i, j, ki, kj) only depends on strictly smaller i + j, so it is acyclic.  \n\n4. Base  \n• x(n, n, 0, 0) is true (all matched!).  \n• x(n, j, ki, kj) is false if ki > 0 (no more characters in A).  \n• x(i, n, ki, kj) is false if kj > 0 (no more characters in B).  \n\n5. Original  \n• Solve subproblems via recursive top-down or iterative bottom-up approach.  \n• Solution to the original problem is x(n, n, n/2, n/2).  \n\n6. Time  \n• Number of subproblems: O(n⁴).  \n• Work per subproblem: O(1).  \n• Overall time complexity: O(n⁴).  \n",
            "problem_number": "2",
            "context": "A wealthy family, Alice, Bob, and their young son Charlie are sailing around the world when they encounter a massive storm. Charlie is thrown overboard, presumed drowned. Twenty years later, a man comes to Alice and Bob claiming to be Charlie. Alice and Bob are excited, but skeptical. Alice and Bob order a DNA matching test from the genetic testing company 46AndThee. Given three length-n DNA sequences from Alice, Bob, and Charlie, the testing center will determine ancestry as follows: if Charlie's DNA can be partitioned into two (not necessarily contiguous) subsequences of equal length, where one is a subsequence of Alice's DNA, and the other is a subsequence of Bob's DNA, the Charlie is their son. For example, suppose Alice's DNA is AATT and Bob's DNA is CCGG. If Charlie's DNA were CATG, he would be matched as their son, since CATG can be partitioned into disjoint subsequences CG and AT which are subsequences of Alice and Bob's DNA respectively. However, Charlie would be found to be an imposter if his DNA were AGTC."
        },
        {
            "question": "Describe an O(nks)-time algorithm to find the maximum volume of food Obert can eat given his diet.",
            "answer": "1. Subproblems  \n• x(i, j, s0): maximum volume of food possible when purchasing a suffix of plates pᵢ to pₙ₋₁,  \n  using at most j calories and ordering exactly s0 sweet plates.  \n• Defined for i ∈ {0,...,n}, j ∈ {0,...,k}, s0 ∈ {0,...,s}.  \n\n2. Relate  \n• Either order plate pᵢ or not. Guess!  \n• If ordering pᵢ, gain vᵢ in volume but use cᵢ calories.  \n• If pᵢ is sweet, must order one fewer sweet plate.  \n• The recurrence relation:  \nx(i, j, s0) = max { x(i + 1, j, s0), vᵢ + x(i + 1, j - cᵢ, s0 - sᵢ) if cᵢ ≤ j and sᵢ ≤ s0 }\n\n3. Topo  \n• Subproblems x(i, j, s0) only depend on strictly larger i, so it is acyclic.  \n\n4. Base  \n• x(n, j, 0) = 0 for any j (no more plates to eat).  \n• x(n, j, s0) = −∞ for s0 > 0 and any j (no more plates, but still need to eat sweet).  \n\n5. Original  \n• Solution given by x(0, k, s).  \n\n6. Time  \n• Number of subproblems: O(nks).  \n• Work per subproblem: O(1).  \n• Overall time complexity: O(nks).  \n",
            "problem_number": "3",
            "context": "Obert Ratkins is having dinner at an upscale tapas bar, where he will order many small plates. There are n plates of food on the menu, where information for plate i is given by a triple of non-negative integers $(V_i, C_i, S_i)$: the plate's volume $v_i$, calories $c_i$, and sweetness $s_i \\in {0,1}$ (the plate is sweet if $s_i=1$ and not sweet if $s_i=0$). Obert is on a diet: he wants to eat no more than k calories during his meal, but wants to fill his stomach as much as possible. He also wants to order exactly s < n sweet plates, without purchasing the same dish twice."
        },
        {
            "question": "Given the price lists of in-game purchases and ride sharing trips between all pairs of monsters, describe an O(n\u00b2)-time algorithm to determine the minimum amount of money Kash must spend in order to catch all n monsters, assuming that she starts at the location of monster m\u2081.",
            "answer": "1. Subproblems  \n• x(i, j): minimum cost of catching monsters mᵢ to mₙ, starting at location mⱼ for j ≤ i.  \n\n2. Relate  \n• If already at the location of monster mᵢ, catch it for free!  \n• Otherwise, acquire monster mᵢ either by purchasing or ride-sharing to its location. Guess!  \n• If purchasing, spend cᵢ dollars; otherwise, ride-share from mⱼ to mᵢ.  \n• The recurrence relation:  \n\nx(i, j) = min { x(i + 1, j) if j = i, cᵢ + x(i + 1, j), s(j, i) + x(i, i) }\n\n3. Topo  \n• Subproblems x(i, j) only depend on strictly larger i + j, so it is acyclic.  \n\n4. Base  \n• x(n + 1, j) = 0 for any j (no cost when no monsters are left to catch).  \n\n5. Original  \n• Solution given by x(1, 1).  \n\n6. Time  \n• Number of subproblems: O(n²).  \n• Work per subproblem: O(1).  \n• Overall time complexity: O(n²).  \n",
            "problem_number": "4",
            "context": "Kash Etchum wants to play Gokemon Po, a new augmented reality game. The goal is to catch a set of n monsters who reside at specific locations in her town. Monsters must be obtained in a specific order: before Kash can obtain monster mi, she must have already obtained all monsters mj for j < i. To obtain monster mi, Kash may either purchase the monster in-game for positive integer ci dollars, or she may catch mi for free from that monster's location. If Kash is not at the monster's location, she will have to pay a ride share service to drive her there. The minimum possible cost to transport from the location of monster mi to the location of monster m; via ride sharing is denoted by the positive integer s(i, j)."
        }
    ]
}
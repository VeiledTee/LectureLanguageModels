{
    "questions": [
        {
            "question": "2^{2\u03b7} \u2208 \u0398(2\u03b7).",
            "answer": "False. This statement is equivalent to saying k\u00b2 \u2208 O(k) for k = 2n. Constants in exponents matter asymptotically!",
            "problem_number": "2(a)",
            "context": "Problem 2. [40 points] Decision Problems (10 parts)\nFor each of the following questions, circle either T (True) or F (False), and briefly justify your answer in the box provided (a single sentence or picture should be sufficient). Each problem is worth 4 points: 2 points for your answer and 2 points for your justification. If you leave both answer and justification blank, you will receive 1 point."
        },
        {
            "question": "If T(n) = 2T (n) + n\u00b2 and T(1) = \u0398(1), then T(n) = O(n\u00b2).",
            "answer": "False. This is an example of Case II of Master Theorem, since\na = 1, b = 3, f(n) = n\u00b2 and n\u00b2 = O(nlog3/29/4 log n). Thus, the recurrence\nevaluates to T(n) = O(n\u00b2 log n), which is not O(n\u00b2).",
            "problem_number": "2(b)",
            "context": "Problem 2. [40 points] Decision Problems (10 parts)\nFor each of the following questions, circle either T (True) or F (False), and briefly justify your answer in the box provided (a single sentence or picture should be sufficient). Each problem is worth 4 points: 2 points for your answer and 2 points for your justification. If you leave both answer and justification blank, you will receive 1 point."
        },
        {
            "question": "Performing an O(1) amortized operation n times on an initially empty\ndata structure takes worst-case O(n) time.",
            "answer": "True. This is the definition of amortization.",
            "problem_number": "2(c)",
            "context": "Problem 2. [40 points] Decision Problems (10 parts)\nFor each of the following questions, circle either T (True) or F (False), and briefly justify your answer in the box provided (a single sentence or picture should be sufficient). Each problem is worth 4 points: 2 points for your answer and 2 points for your justification. If you leave both answer and justification blank, you will receive 1 point."
        },
        {
            "question": "Given an array A containing n comparable items, sort A using merge sort. While\nsorting, each item in A is compared with O(log n) other items of A.",
            "answer": "False. As a counter example, during the final merge step between\ntwo sorted halves of the array, each of size O(n), a single item from one array\nmay get compared to all the items from the other list.",
            "problem_number": "2(d)",
            "context": "Problem 2. [40 points] Decision Problems (10 parts)\nFor each of the following questions, circle either T (True) or F (False), and briefly justify your answer in the box provided (a single sentence or picture should be sufficient). Each problem is worth 4 points: 2 points for your answer and 2 points for your justification. If you leave both answer and justification blank, you will receive 1 point."
        },
        {
            "question": "Given a binary min-heap storing n items with comparable keys, one can build a\nSet AVL Tree containing the same items using O(n) comparisons.",
            "answer": "False. If such an algorithm A existed, we would be able to sort an\narray of comparable items in O(n) time, which would contradict the \u03a9(n log n)\ncomparison sort lower bound. Specifically, we could build a binary min-heap\nfrom the array using O(n) comparisons, use A to construct a Set AVL Tree in\nO(n) comparisons, and then return its traversal order.",
            "problem_number": "2(e)",
            "context": "Problem 2. [40 points] Decision Problems (10 parts)\nFor each of the following questions, circle either T (True) or F (False), and briefly justify your answer in the box provided (a single sentence or picture should be sufficient). Each problem is worth 4 points: 2 points for your answer and 2 points for your justification. If you leave both answer and justification blank, you will receive 1 point."
        },
        {
            "question": "Given a directed graph G = (V, E), run breadth-first search from a vertex s \u2208 V.\nWhile processing a vertex u, if some v \u2208 Adj+(u) has already been processed,\nthen G contains a directed cycle.",
            "answer": "False. BFS can't be used to find directed cycles. A counterexample\nis V = {s, a, b,t} and E = {(s, t), (s, a), (a, b), (b, t)}. Running BFS from s\nwill first process vertices in levels {s}, then {a, t}, then {b}. When processing\nvertex b, vertex t \u2208 Adj+(b) has already been processed, yet G is a DAG.",
            "problem_number": "2(f)",
            "context": "Problem 2. [40 points] Decision Problems (10 parts)\nFor each of the following questions, circle either T (True) or F (False), and briefly justify your answer in the box provided (a single sentence or picture should be sufficient). Each problem is worth 4 points: 2 points for your answer and 2 points for your justification. If you leave both answer and justification blank, you will receive 1 point."
        },
        {
            "question": "Run Bellman-Ford on a weighted graph G = (V, E, w) from a vertex s \u2208 V. If\nthere is a witness v \u2208 V, i.e., \u03b4\u03b9\u03bd\u03b9(\u03c2,\u03c5) < \u03b4\u03b9\u03bd\u22121(s, v), then v is on a negative-\nweight cycle of G.",
            "answer": "False. A witness is only guaranteed to be reachable from a negative-\nweight cycle; it may not actually be on a negative-weight cycle.",
            "problem_number": "2(g)",
            "context": "Problem 2. [40 points] Decision Problems (10 parts)\nFor each of the following questions, circle either T (True) or F (False), and briefly justify your answer in the box provided (a single sentence or picture should be sufficient). Each problem is worth 4 points: 2 points for your answer and 2 points for your justification. If you leave both answer and justification blank, you will receive 1 point."
        },
        {
            "question": "Floyd-Warshall and Johnson's Algorithm solve all-pairs shortest paths in the\nsame asymptotic running time when applied to weighted complete graphs, i.e.,\ngraphs where every vertex has an edge to every other vertex.",
            "answer": "True. A complete graph is dense, i.e., |E| = \u0398(|V|\u00b2), so Johnson's\nalgorithm runs in O(|V|\u00b2 log |V| + |V||E|) = O(|V|\u00b3) time, which is the same\nas Floyd-Warshall.",
            "problem_number": "2(h)",
            "context": "Problem 2. [40 points] Decision Problems (10 parts)\nFor each of the following questions, circle either T (True) or F (False), and briefly justify your answer in the box provided (a single sentence or picture should be sufficient). Each problem is worth 4 points: 2 points for your answer and 2 points for your justification. If you leave both answer and justification blank, you will receive 1 point."
        },
        {
            "question": "If there is an algorithm to solve 0-1 Knapsack in polynomial time, then there is\nalso an algorithm to solve Subset Sum in polynomial time.",
            "answer": "True. Subset Sum is the special case of 0-1 Knapsack. Specifically,\none can (in linear time) convert an instance (A, T) of Subset Sum into an equiv-\nalent instance of 0-1 Knapsack, with an item i for each integer a\u017c \u2208 A having\nsize si = ai and value v\u2081 = ai, needing to fill a knapsack of size T; and then\nsolve the instance via the polynomial-time algorithm for 0-1 Knapsack.",
            "problem_number": "2(i)",
            "context": "Problem 2. [40 points] Decision Problems (10 parts)\nFor each of the following questions, circle either T (True) or F (False), and briefly justify your answer in the box provided (a single sentence or picture should be sufficient). Each problem is worth 4 points: 2 points for your answer and 2 points for your justification. If you leave both answer and justification blank, you will receive 1 point."
        },
        {
            "question": "Suppose a decision problem A has a pseudopolynomial-time algorithm to solve A.\nIf P \u2260 NP, then A is not solvable in polynomial time.",
            "answer": "False. A problem could have a pseudopolynomial-time algorithm\nand a polynomial-time algorithm. In fact, any polynomial-time algorithm is\nalso a pseudopolynomial-time algorithm!",
            "problem_number": "2(j)",
            "context": "Problem 2. [40 points] Decision Problems (10 parts)\nFor each of the following questions, circle either T (True) or F (False), and briefly justify your answer in the box provided (a single sentence or picture should be sufficient). Each problem is worth 4 points: 2 points for your answer and 2 points for your justification. If you leave both answer and justification blank, you will receive 1 point."
        },
        {
            "question": "Given a connected undirected weighted graph G = (V, E, w), where every edge has a unique\ninteger weight, describe an O(|E|log |E|)-time algorithm to determine the largest value of k such\nthat Gk is not connected.",
            "answer": "Construct an array A containing the |E| distinct edge weights in G, and sort it in\nO(|E|log |E|) time, e.g., using merge sort. We will binary search to find k. Specifically, consider\nan edge weight k' in A (initially the median edge weight), and run a reachability algorithm (e.g.,\nFull-BFS or Full-DFS) to compute the reachability of an arbitrary vertex x \u2208 V in O(|E|) time.\nIf exactly V vertices are reachable from x, then Ge is connected and k > k'; recurse on strictly\nlarger values for k'. Otherwise, Gk is not connected, so k \u2264 k'; recurse on non-strictly smaller\nvalues for k'. By dividing the search range by a constant fraction at each step (i.e., by always\nchoosing the median index weight of the unsearched space), binary search will terminate after\nO(log |E|) steps, identifying the largest value of k such that Gk is not connected. This algorithm\ntakes O(|E|log |E|) time to sort, and computes reachability of a vertex in O(|E|) time, O(log |E|)\ntimes, so this algorithm runs in O(|E| log |E|) time in total.",
            "problem_number": "6",
            "context": "Problem 6. [14 points] Limited Connections\nFor any weighted graph G = (V, E, w) and integer k, define Ge to be the graph that results from\nremoving every edge in G having weight k or larger."
        },
        {
            "question": "Describe an O(nd)-time algorithm to determine whether it is possible for Dal and Sean to drive\nfrom Yew Nork to Fan Sancrisco in at most d days, spending at most b on expenses along the way.",
            "answer": "Let C = {Co, . . ., Cn-1}, and let cs denote Yew Nork and let ct denote Fan Sancrisco.\nConstruct a graph G with:\n\u2022 a vertex (ci, d') for each city c\u2081 \u2208 C and day d' \u2208 {0, . . ., d},\nrepresenting staying the night in city c\u2081 on the night before day d'; and\n\u2022 a directed weighted edge ((ci, d'), (cj, d' + 1)) with weight g(ci, Cj) + h(cj)\nfor each city ci \u2208 C, cj \u2208 Li and d' \u2208 {0, . . ., d \u2013 1}.\nThen the weight of any path in G from vertex (cs,0) to any vertex (ct, d') for d' \u2208 {0,...,d}\ncorresponds to the expenses incurred along a driving route from Yew Nork to Fan Sancrisco in\nat most d days (assuming they stay the night upon reaching ct; other assumptions are also okay).\nG is acyclic, since each edge always connects a vertex from a smaller day to a larger day, so run\nDAG Relaxation to compute single-source shortest paths from (cs, 0) in G. Then return whether\nd((cs, 0), (Ct, d')) \u2264 b for any d' \u2208 {0,...d}. G has O(nd) vertices and O(nd) edges (since\n|Li| \u2264 10 for all i\u2208 {0,...,n \u2013 1}), so DAG relaxation runs in O(nd) time and checking all\ndestination values takes O(d) time, leading to O(nd) time in total.",
            "problem_number": "7",
            "context": "Problem 7. [14 points] On the Street\nFriends Dal and Sean want to take a car trip across the country from Yew Nork to Fan Sancrisco\nby driving between cities during the day, and staying at a hotel in some city each night. There are\nn cities across the country. For each city ci, Dal and Sean have compiled:\n\u2022 the positive integer expense h(c\u2081) of staying at a hotel in city c\u2081 for one night; and\n\u2022 a list Li of the at most 10 other cities they could drive to in a single day starting from city Ci,\nalong with the positive integer expense g(ci, Cj) required to drive directly from ci to cj for\neach cj \u2208 Li."
        },
        {
            "question": "Given G, c, a red vertex s \u2208 Vr, and a blue vertex t \u2208 V\u266d, describe an O(|V|)-time algorithm to\ncompute d(s, t), the minimum weight of any path from s to t.",
            "answer": "Any path from s to t is a path through edges in Er, followed by a path through edges\nin Eg, followed by a (possibly empty) path through edges in Eb. So we compute minimum weight\ndistances in G incrementally, first using edges in Er, then using edges in Eg, then edges in Eb.\nStep 1: Construct unweighted graph G' = (V', E') composed of the edges E' = Er and the\nvertices appearing in those edges, specifically V' = U(u,v)\u2208E, {u, v} (which contains vertices from\nV and Vg). Run breadth-first search from s in G' to compute unweighted distances. Then the\nminimum weight distance in G from s to any green vertex in V' \u2229 V, is wr times the unweighted\ndistance computed. G' has size O(|V|), so this step takes O(|V|) time.\nStep 2: Now construct weighted graph G\" = (V\", E\") composed of vertex s with a new directed\nedge to each green vertex in V' \u2229 V, weighted by its distance found in Step 1 (i.e., the minimum\nweight of any path from s to that vertex), along with weighted edges Eg and the vertices appearing\nin those edges. All the weights in G\" are positive, so run Dijkstra from s in G\" to compute\nminimum weight distances. Then the computed distance to any blue vertex v in V\" \u2229 V is the\nminimum weight of any path from s to v in G that traverses only red or green edges. G\" has size\nO(1 + |Vg| + |Eg|) = O(|V|0.99), so this step takes O(|V|0.99 log |V|0.99) = O(|V|) time.\nStep 3: Now construct a weighted graph G''' = (V''', E''') composed of vertex s with a new directed\nedge to each blue vertex in V\" \u2229 V weighted by its distance found in Step 2 (i.e., the minimum\nweight of any path from s to that vertex), along with weighted edges E\u266d and the vertices appearing\nin those edges. Weights in G'' may be positive or negative, so run Bellman-Ford from s in G'' to\ncompute weighted minimum weight distances. Then the computed distance to t is the minimum\nweight of any path from s to t in G, as desired. G'' has size O(1 + |V6| + |E6|) = O(\u221aVI), so\nthis step takes O(\u221a[V]\u221a[V]) = 0(|V|) time, leading to O(|V|) time in total.",
            "problem_number": "8",
            "context": "Problem 8. [18 points] RGB Graph\nLet G = (V, E, w) be a weighted directed graph. Let c : V \u2192 {r, g, b} be an assignment of each\nvertex v to a color c(v), representing red, green, or blue respectively. For x \u2208 {r, g, b},\n\u2022 let V x be the set of vertices with color x, i.e., V\u2081 = {v \u2208 V | c(v) = x}; and\n\u2022 let Ex be the set of edges outgoing from vertices in V\u2082, i.e., Ex = {(u,v) \u2208 E | u \u2208 V\u2081}.\nSuppose graph G and coloring c have the following properties:\n1. Every edge in E either connects two vertices of the same color,\ngoes from a red vertex to a green vertex, or goes from a green vertex to a blue vertex.\n2. |V,| = |Er| = O(|V|), and edges in Er have identical positive integer weight wr.\n3. |Vg| = |Eg| = O(|V|0.99), and edges in Eg have nonnegative integer weights.\n4. |V6| = |E6| = O(\u221a|V|), and edges in Es can have positive or negative integer weights."
        },
        {
            "question": "Describe an O(n\u00b2m)-time algorithm to count the number of (m, k)-separated subsets of S.",
            "answer": "1. Subproblems\n\u2022 First sort the integers in S increasing into array A in O(n log n) time, e.g., via merge sort\n\u2022 where A = (ao,..., an-1)\n\u2022 x(i, j): the number of (j, k)-separated subsets of suffix A[i :]\n\u2022 for i \u2208 {0, . . ., n} and j \u2208 {0, ...,m}\n2. Relate\n\u2022 Sum the number of (j, k)-separated subsets using A[i] with the ones that do not use A[i]\n\u2022 If A[i] < j is used:\n\u2013 Then no integer in A[i :] smaller than A[i] + k may be used\n\u2013 Let f (i) be the smallest index greater than i such that A[f(i)] \u2013 A[i] \u2265 k\n\u2013 Then recrusively count x(f(i), j \u2013 A[i])\n\u2022 Otherwise, A[i] is not used and we can recursively count x(i + 1, j)\n\u03a3{\nx(f(i), j - A[i]) if A[i] < j,\nx(i + 1, j)\nalways\n}\n3. Topo\n3. Topo\n\u2022 Subproblem x(i, j) only depends on strictly larger i, so acyclic\n4. Base\n\u2022 x(n, 0) = 1, the empty subset can always be acheived\n\u2022 x(n, j) = 0 for j > 0, empty sets cannot sum to a positive number\n5. Original\n\u2022 x(0, m), the number of (m, k)-separated subsets of A\n6. Time\n\u2022 # subproblems: (n + 1)(m + 1) = O(nm)\n\u2022 Work per subproblem: O(n) to find f(i) by linear scan\n\u2022 O(n\u00b2m) time in total\n\u2022 (Note that it is possible to compute f(i) in O(log n) time via binary search, or in amor-\ntized O(1) time from f (i - 1), but these optimizations are not necessariy for full points.)",
            "problem_number": "9",
            "context": "Problem 9. [16 points] Separated Subsets\nFor any set S of integers and for any positive integers m and k, an (m, k)-separated subset of S\nis any subset S' \u2286 S such that S' sums to m and every pair of distinct integers a, b \u2208 S' satisfies\n|a \u2013 b| \u2265 k. Given positive integers m and k, and a set S containing n distinct positive integers,\ndescribe an O(n\u00b2m)-time algorithm to count the number of (m, k)-separated subsets of S.\n(When solving this problem, you may assume that a single machine word is large enough to hold\nany integer computed during your algorithm.)"
        },
        {
            "question": "Given Ted's guest information, describe an O(n\u00b3)-time algorithm to determine a respectful seating\norder that minimizes the sum of mutual hatred between pairs of guests seated next to each other.",
            "answer": "1. Subproblems\n\u2022 Sort the guests increasing by favor in O(n log n) time into F = (fo, ..., f2n-1)\n\u2022 Any partition of F into two length-n subsequences corresponds to a respectful seating\n\u2022 x(i, JL, JR, N\u2081): minimum total hatred of adjacent guests possible by respectfully seating\nthe n i guests from suffix F[i:] next to the Queen, with n\u2081 guests to the left and\nNR = (n - i) - n\u2081 guests to the right, where guest j\u2081 < i has already been seated n\u2081 +1\nplaces to the left, and guest jR < i has already been seated NR + 1 places to the right.\n\u2022 for i\u2208 {0, . . ., 2n}, JL, JR \u2208 {\u22121, ..., 2n \u2212 1} and n\u2081 \u2208 {0,...,n}\nwhere either j\u2081 = i \u2212 1 or j\u20a8 = i \u2212 1\n\u2022 Let d(\u22121,i) = d(i, \u22121) = 0 for all i \u2208 {0, . . ., 2n \u2013 1} (no hatred at the end of table)\n2. Relate\n\u2022 Guess whether guest i is seated on the right or left\n\u2022 Sitting next to j\u2081 costs hatred d(i, j\u2081); sitting next to JR costs hatred d(i, jr)\nx(i, JL, JR, NL)\n=min\nd(i, j\u2081) + x(i + 1, i, jR, NL \u2212 1) if n\u2081 > 0,\nd(i, jr) + x(i + 1, j\u0141, i, n\u2081)\nif (n - i) - n\u2081 > 0\n3. Topo: Subproblem x(i, JL, JR, NL) only depends on strictly larger i, so acyclic\n4. Base: x(2n, JL, JR, 0) = 0 for all jL, JR \u2208 {0, . . ., 2n} (no hatred if no guests)\n5. Original: x(0, -1, -1, n), min hatred of adjacent guests by respectfully seating all guests\n6. Time\n\u2022 # subproblems: though there are four parameters, there are only O(n\u00b3) subproblems for\nwhich either j\u2081 = i 1 or j = i -1\n\u2022 Work per subproblem: O(1), so O(n\u00b3) time in total",
            "problem_number": "10",
            "context": "Problem 10. [18 points] A Feast for Crowns\nTed Snark is arranging a feast for the Queen of Southeros and her guests, and has been tasked with\nseating them along one side of a long banquet table.\n\u2022 Ted has a list of the 2n guests, where each guest i has a known distinct positive integer fi\ndenoting the guest's favor with the Queen.\n\u2022 Ted must seat the guests respectfully: the Queen must be seated in the center with n guests\non either side so that guests' favor monotonically decreases away from the Queen, i.e., any\nguest seated between a guest i and the Queen must have favor larger than fi.\n\u2022 Additionally, every guest hates every other guest: for every two guests i, j, Ted knows the\npositive integer mutual hatred d(i, j) = d(j, i) between them."
        },
        {
            "question": "Given an array A containing n distinct positive integers, describe an O(n\u00b2)-time algorithm to determine\nwhether four integers from A form a Pythagorean Quad, where integers from A may appear more\nthan once in the Quad. State whether your running time is worst-case, expected, and/or amortized.",
            "answer": "First, we observe that it suffices to find (a, b, c, d) such that a\u00b2 + b\u00b2 = d\u00b2 \u2013 c\u00b2. Let P\nbe the set of n\u00b2 ordered pairs of integers from A, where integers in A may be repeated in a pair.\nConstruct an empty hash table H, and for each pair (a, b) \u2208 P, compute and insert value a\u00b2 + b\u00b2\ninto H. Then for each pair (c, d) \u2208 P, compute and lookup value d\u00b2 \u2013 c\u00b2 in H. If the value is in\nH, then some a\u00b2 + b\u00b2 equals some d\u00b2 \u2013 c\u00b2, so return that a Pythagorean Quad exists. Otherwise,\nif no d\u00b2 - c\u00b2 exists in H, then return that a Pythagorean Quad does not exist. Each a\u00b2 + b\u00b2 or\nd\u00b2 \u2013 c\u00b2 value takes constant time to compute, so computing them all takes worst-case O(n\u00b2) time,\nwhile inserting them into or looking them up in the hash table takes expected O(n\u00b2) time, so this\nalgorithm runs expected in O(n\u00b2) time in total.",
            "problem_number": "4",
            "context": "Problem 4. [14 points] Pythagorean Quad\nA Pythagorean Quad consists of four integers (a, b, c, d) such that d \u221aa\u00b2 + b\u00b2 + c\u00b2. Given\nan array A containing n distinct positive integers, describe an O(n\u00b2)-time algorithm to determine\nwhether four integers from A form a Pythagorean Quad, where integers from A may appear more\nthan once in the Quad. State whether your running time is worst-case, expected, and/or amortized."
        },
        {
            "question": "Describe a database to store animal sightings, supporting the following four operations, where n\nis the number of sightings stored in the database at the time of the operation. State whether your\nrunning times are worst-case, expected, and/or amortized.\ninitialize()\nadd_sighting(s, i)\nremove_oldest()\nis_common(s)",
            "answer": "To implement the database, maintain the following data structures:\n\u2022 A hash table H mapping each species s to a Set AVL tree T\n\u2022 Each Set AVL Tree T\u300f stores pairs (i, ci) of zone numbers i and the count ci representing the\nnumber of sightings of species s in zone i, keyed by zone number.\n\u2022 Augment each node x in each T, by the maximum number of sightings x.m of any zone in\nthe subtree of x. x.m can be maintained in O(1) time from the augmentations of x's children,\nspecifically x.m = max{x.left.m,x.key,x.right.m}.\n\u2022 A doubly-linked list L of all current sightings (s, i) in the order in which they were added to\nthe database (oldest at the front).\nTo implement initialize(), initialize an empty H and empty L in worst-case O(1) time.\nTo implement add_sighting(s, i), lookup s in H to find T, in expected O(1) time (if s does\nnot exist in H, insert s mapping to an empty T, in expected amortized O(1) time). Then find zone\ni in Ts. If zone i is not in Ts, insert (i, 1) into Ts. Otherwise, i is in Ts, so remove (i, ci) from Ts\nand reinsert (i, c\u2081 + 1). It takes worst-case O(log n) time to remove or insert items from T, while\nmaintaining augmentations (since at most n sightings could exist for species s). Lastly, Insert (s, i)\nto the back of L in worst-case O(1) time. Thus this operation takes O(log n) expected amortized\ntime, and maintains the invariants of the database directly.\nTo implement remove_oldest (), remove the oldest pair (s, i) from the front of L in worst-case\nO(1) time. Lookup s in H to find T, in expected O(1) time; then lookup i in Ts and decrease\nCi by one. If ci is decreased to zero, remove i from Ts. If Ts becomes empty, remove s from\nH in expected amortized O(1) time. This operation takes O(log n) expected amortized time, and\nmaintains the invariants of the database directly.\nTo implement is_common(s), simply lookup s in H and return whether s is in H and the stored\nmax at the root of T is 100 or greater in expected O(1) time. This operation is correct based on\nthe invariants of the data structure.",
            "problem_number": "5",
            "context": "Problem 5. [20 points] Animal Counting\nPurpleRock Park is a wildlife reserve, divided into zones, where each zone has a park ranger\nwho records current sightings of animals of different species over time. Old animal sightings are\nperiodically removed from the database. A species s is common if current park records contain at\nleast 100 sightings of species s within any single zone of the park.\nDescribe a database to store animal sightings, supporting the following four operations, where n\nis the number of sightings stored in the database at the time of the operation. State whether your\nrunning times are worst-case, expected, and/or amortized.\ninitialize()\nInitialize an empty database in O(1) time\nadd_sighting(s, i)\nRecord a newest sighting of species s in zone i in O(log n) time\nremove_oldest()\nRemove the oldest sighting stored in the database in O(log n) time\nis_common(s)\nReturn whether species s is common based on sightings\nthat have not yet been removed from the database in O(1) time"
        },
        {
            "question": "Given a k-even-mixed array A containing n distinct integers for k = [n/lgn], describe an O(n)-time algorithm to\nsort A.",
            "answer": "Scan through A and put all even integers in order into an array AE and all\nodd integers in order into an array Ao (where |AE| = k and |Ao| = n k). Ao is\nsorted by definition, and we can sort A\u0118 in O(k logk) = O((n/lgn) log(n/lgn)) =\nO(n) time, e.g., via merge sort. Then we can merge sorted AE and Ao back into A in\nO(n) time using the merge step of merge sort, using O(n) time in total.",
            "problem_number": "3(a)",
            "context": "Problem 3. [24 points] Sorting Sorts\nAn integer array A is k-even-mixed if there are exactly k even integers\nin A, and the odd integers in A appear in sorted order. Given a k-even-mixed array A\ncontaining n distinct integers for k = [n/lgn], describe an O(n)-time algorithm to\nsort A."
        },
        {
            "question": "Let A be an array of n pairs of positive integers (xi, Yi) with Xi, Yi < n\u00b2\nfor all i \u2208 {0, . . ., n \u2212 1}. The power of pair (x, y) is the integer x + n\u00ba. Describe an\nO(n)-time algorithm to sort the pairs in A increasing by power.",
            "answer": "First note that x < ny for any integer y > 1 and for any x \u2208 {0, . . ., n\u00b2\u22121}.\nScan through A and put all pairs having y = 1 into array A\u2081, and all other pairs into\narray A2. Sort A\u2081 directly by computing and comparing their respective powers x+n.\nSince these values are bounded above by O(n\u00b2), sort A\u2081 in O(n) time using Radix\nsort. To sort A2, use tuple sort, sorting first by x values and then by y values (since\npower is more sensitive to changes in y). Since the x and y values are both bounded\nabove by O(n\u00b2), we can use Radix sort for tuple sort's stable sorting algorithm to sort\nA2 in O(n) time. Then merge A\u2081 and A2 back into A in O(n) time using the merge\nstep of merge sort, using O(n) time in total.",
            "problem_number": "3(b)",
            "context": "Problem 3. [24 points] Sorting Sorts\nLet A be an array of n pairs of positive integers (xi, Yi) with Xi, Yi < n\u00b2\nfor all i \u2208 {0, . . ., n \u2212 1}. The power of pair (x, y) is the integer x + n\u00ba. Describe an\nO(n)-time algorithm to sort the pairs in A increasing by power."
        }
    ]
}
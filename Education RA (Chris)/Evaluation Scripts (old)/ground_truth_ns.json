[
    {
        "problem_number": "2",
        "question": "It is well known that re-using a \"one-time pad\" can be insecure. This problem explores this issue, with some variations.\n\nIn this problem all characters are represented as 8-bit bytes with the usual US-ASCII encoding (e.g.\"A\" is encoded as 0x41). The bitwise exclusive-or of two bytes \\(x\\) and \\(y\\) is denoted \\(x\\oplus y\\).\n\nLet \\(M=(m_{1},m_{2},\\ldots,m_{n})\\) be a message, consisting of a sequence of \\(n\\) message bytes, to be encrypted. Let \\(P=(p_{1},p_{2},\\ldots,p_{n})\\) denote a pad, consisting of a coresponding sequence of (randomly chosen) \"pad bytes\" (key bytes).\n\nIn the usual one-time pad, the sequence \\(C=(c_{1},c_{2},\\ldots,c_{n})\\) of ciphertext bytes is obtained by xor-ing each message byte with the corresponding pad byte:\n\n\\[c_{i}=m_{i}\\oplus p_{i},\\mbox{ for }i=1\\ldots n\\;.\\]",
        "subquestions": [
            {
                "problem_number": "2a",
                "question": "Here are two 8-character English words encrypted with the same \"one-time pad\". What are the words? \\[\\begin{array}{l}\\mbox{\\tt e9~3a~e9~c5~fc~73~55~d5}\\\\ \\mbox{\\tt f4~3a~fe~c7~e1~68~4a~df}\\end{array}\\] Describe how you figured out the words.",
                "answer": "To decode the ciphertexts, we XORed them together, which gives \\(C_1 \\oplus C_2 = (M_1 \\oplus P) \\oplus (M_2 \\oplus P) = M_1 \\oplus M_2\\). Thus the pad \\(P\\) is irrelevant. Then we found a set of 8-character words from an English dictionary. For each \\(M_1\\) in this set, we constructed \\(M_2\\) by XORing \\(M_1\\) with \\(C_1 \\oplus C_2\\), since \\(M_1 \\oplus (C_1 \\oplus C_2) = M_1 \\oplus (M_1 \\oplus M_2) = M_2\\). Lastly, we checked if \\(M_2\\) was also in the set. If both \\(M_1\\) and \\(M_2\\) were in the set (as valid English words), then we outputted them.\n\nC1 = [0xe9, 0x3a, 0xe9, 0xc5, 0xfc, 0x73, 0x55, 0xd5]\nC2 = [0xf4, 0x3a, 0xfe, 0xc7, 0xe1, 0x68, 0x4a, 0xdf]\nM1_XOR_M2 = [c ^ d for c, d in zip(C1, C2)]\n...\nOutput of running the code:\nword1 = networks, word2 = security, pad = [135, 95, 157, 178, 147, 1, 62, 166]\nword1 = security, word2 = networks, pad = [154, 95, 138, 176, 142, 26, 33, 172]\n\nThough their ordering is indiscernible, the two words are security and networks.",
                "custom_id": "request_S14_ps1_0_0"
            },
            {
                "problem_number": "2b",
                "question": "Ben Bitdiddle decided to fix this problem by making sure that you can't just \"cancel\" pad bytes by xor-ing the ciphertext bytes. In his scheme the key is still as long as the ciphertext. If we define \\(c_{0}=0\\) for notational convenience, then the ciphertext bytes \\(c_{1},c_{2},\\ldots,c_{n}\\) are obtained as follows: \\[c_{i}=m_{i}\\oplus((p_{i}+c_{i-1})\\bmod 256)\\ .\\] That is, each ciphertext byte is added to the next key byte and the addition result (modulo 256) is used to encrypt to the next plaintext byte. Ben is now confident he can reuse his pad, since \\((k_{i}+c_{i-1})\\bmod 256\\) will be different for different messages, so nobody would be able to cancel the \\(k_{i}\\)'s out. You are provided with otp-feedback.py, which contains an implementation of Ben's algorithm. You are also given the file tenciphs.txt, containing ten ciphertexts \\(C_{1},C_{2},\\ldots,C_{10}\\) produced by Ben, using the _same_ pad \\(P\\). You know that these messages contain valid English text. Submit the messages and the pad, along with a careful explanation of how you found them, and any code you used to help find the messages. The most important part is the explanation.",
                "answer": "Messages and Pad:\nWe stand today on the brink of a revolution in cryptography. Probabilistic encryption is the use of randomness in an ener Secure Sockets Layer (SSL), are cryptographic protocols that This document will detail a vulnerability in the ssh cryptog MIT developed Kerberos to protect network services provided NIST announced a competition to develop a new cryptographic Diffie-Hellman establishes a shared secret that can be used Public-key cryptography refers to a cryptographic system req The keys used to sign the certificates had been stolen from We hope this inspires others to work in this fascinating fie\n\npad = [119, 75, 116, 51, 85, 113, 72, 105, 76, 78, 114, 79, 84, 49, 71, 101, 71, 88, 116, 78, 113, 102, 113, 87, 84, 65, 51, 55, 99, 56, 107, 69, 116, 105, 110, 109, 97, 113, 79, 106, 122, 68, 66, 98, 77, 72, 112, 72, 55, 53, 104, 54, 99, 71, 87, 97, 68, 98, 112, 49]\n\nProcess:\nThis part's code was more interactive because, due to Ben's addition of feedback, we couldn't simply XOR the 10 ciphertexts together and look up possible messages in the dictionary. Our plan of attack was to first calculate all possible pad bytes (\\(p_i\\)'s) that would result in valid and likely English characters (letters and common punctuation) from all 10 ciphertexts.\n\nvalid_chars = set(range(65, 65 + 26) + range(97, 97 + 26) + [32, 44, 46, 63, 33, 45, 40, 41])\n\n...\nOutput of running the code:\nmessages = ['We stand today on ', 'Probabilistic encr', 'Secure Sockets Lay', 'This document will', 'MIT developed Kerb', 'NIST announced a c', 'Diffie-Hellman est', 'Public-key cryptog', 'The keys used to s', 'We hope this inspi'], pad = [119, 75, 116, 51, 85, 113, 72, 105, 76, 78, 114, 79, 84, 49, 71, 101, 71, 88]\n\nRepeating this process 4x, we eventually got the desired output... The keys used to sign the certificates had been stolen from We hope this inspires others to work in this fascinating fie",
                "custom_id": "request_S14_ps1_0_1"
            }
        ]
    },
    {
        "problem_number": "3",
        "question": "In the previous problem, we saw how to attack a scheme in which a one-time pad, or a scheme like it, is reused. This problem will walk you through how rare pad reuse for the standard one-time pad (not the previous part's scheme) can be efficiently detected. We will look at the extreme case in which a pad is reused just once.\n\nThe following fact may be useful in this problem: Let \\(R_{p}(n)\\) be the longest run of heads in \\(n\\) coin flips, each of which is heads with probability \\(p\\). With high probability as \\(n\\) grows, \\(R_{p}(n)\\) is between \\(\\log_{\\frac{1}{p}}n - \\log_{\\frac{1}{p}}\\ln\\ln n\\) and \\(\\log_{\\frac{1}{p}}n + \\log_{\\frac{1}{p}}\\ln n\\). Note: you are not responsible for this paper; it is provided as a reference only.",
        "subquestions": [
            {
                "problem_number": "3a",
                "question": "Suppose you are given \\(poly(n)\\) \\(n\\)-bit ciphertexts \\(c_{1},\\ldots,c_{l}\\), each of which are properly encrypted with an independently uniformly randomly chosen one-time pad. Show that with high probability, the length of the longest repeated bitstring (i.e. a substring of both \\(c_{i}\\) and \\(c_{j}\\) for some \\(i\neq j\\)) is less than \\(\\log_{2}n + \\log_{2}\\ln n\\).",
                "answer": "We are given \\(f(n)=\\operatorname{poly}(n)\\)\\(n\\)-bit ciphertexts \\(c_{1},\\ldots,c_{f(n)}\\), each from a unique plaintext/pad pair. Our goal is to show that the upper bound on the longest run of matching bits between any two ciphertexts, at any offset, is \\(\\log_{2}\\left(n\\ln n\\right)\\) with high probability.\n\nFirst, consider a pair of ciphertexts \\(c_{i}\\) and \\(c_{j}\\) (\\(i\neq j\\)) with no offset. The longest run of matching bits within the \\(n\\) bits of \\(c_{i}\\) and \\(c_{j}\\) is modeled as the longest run of heads in \\(n\\) coin flips (probability \\(p=0.5\\)). Using the provided fact, the longest run \\(R_{0.5}(n)\\) is less than \\(\\log_{2}\\left(n\\ln n\\right)\\) with high probability.\n\nFor offsets \\(k\\) (\\(0\\leq k<n\\)), the longest run in \\(n-k\\) bits still satisfies \\(R_{0.5}(n-k)\\leq \\log_{2}\\left(n\\ln n\\right)\\). Considering all \\(\\binom{f(n)}{2}\\) pairs and \\(2n-1\\) offsets, the total number of comparisons is \\(\\operatorname{poly}(n)\\). By union bound, the probability that any pair/offset exceeds the bound is negligible, ensuring the upper bound holds with high probability.",
                "custom_id": "request_S14_ps1_1_0"
            },
            {
                "problem_number": "3b",
                "question": "We have collected data on the average length of the longest run of identical characters in identical positions in passages of English text by randomly sampling from the collected works of American writer Winston Churchill. You can find a graph of run length (in characters) versus log of the passage length in characters at http://courses.csail.mit.edu/6.857/2014/files/run_lengths.png. How do these run lengths compare to the previous part's upper bound if English plaintext is US-ASCII encoded?",
                "answer": "Assuming US-ASCII encoding (7 bits per character), the upper bound in bits translates to \\(\\frac{1}{7}\\log_{2}(7n\\ln 7n)\\) in characters. Plotting this against Churchill's data shows that English plaintext exhibits longer average runs than the ciphertext upper bound for large \\(n\\). This is due to language redundancy (e.g., frequent 'e', predictable letter pairs). While ciphertext runs are bounded by \\(\\log_{2}\\left(n\\ln n\\right)\\), English runs grow faster, surpassing the bound when \\(\\log_{2}n > 9\\). The graph highlights this divergence as exponential (plaintext) vs. linear (ciphertext upper bound).",
                "custom_id": "request_S14_ps1_1_1"
            },
            {
                "problem_number": "3c",
                "question": "Show that given \\(poly(n)\\) \\(n\\)-bit ciphertexts with total length \\(N\\) and one instance of pad reuse, you can find the two ciphertexts which share a key in time which is \\(\\tilde{O}(N)\\) in the total ciphertext length. This means that your solution should run in \\(O(N\\log^{c}N)\\) time for some constant \\(c\\).\n\n*Hint: You may wish to use suffix trees...*",
                "answer": "**Algorithm:**\n1. **Concatenate Ciphertexts:** Append unique terminators to each ciphertext and concatenate them into a single string \\(S\\).\n2. **Build Suffix Tree:** Construct a suffix tree for \\(S\\), which takes \\(O(N\\log N)\\) time.\n3. **Find Longest Repeated Substring:** Traverse the suffix tree to identify the deepest internal node, corresponding to the longest repeated substring. If its length \\(d > \\log_{2}\\left(n\\ln n\\right)\\), pad reuse is detected.\n4. **Identify Culprit Ciphertexts:** Trace paths from the node to leaves containing unique terminators, revealing the two ciphertexts sharing the pad.\n\n**Correctness:** Pad reuse creates a long common substring in ciphertexts (exceeding the bound from part (a)), while independent pads do not. Suffix trees efficiently capture this via longest repeated substring.\n\n**Running Time:** Suffix tree construction dominates at \\(O(N\\log N)\\), achieving quasilinear time \\(\\tilde{O}(N)\\).",
                "custom_id": "request_S14_ps1_1_2"
            }
        ]
    },
    {
        "problem_number": "1",
        "question": "Ben Bitdiddle is learning to code, and he has decided to build a website! To authenticate users, he created a database with all of his users' usernames and the SHA-256 hash of their passwords. Unfortunately for him, Eve has stolen the contents of this database.\n\nIn this problem, we will explore some of the space/time tradeoffs which Eve can use to invert cryptographic hashes of passwords. Suppose Eve knows that all the passwords come from a set \\(S\\), and our hash function produces \\(d\\)-bit strings. With no precomputation, if \\(|S|\\) is much smaller than \\(2^{d}\\), then inverting the hash of a password will take Eve about \\(|S|/2\\) tries in expectation, and therefore time that is \\(\\Omega(|S|)\\).\n\nIf Eve had infinite time to prepare for breaking the password hashes, she could construct a lookup table with the hash of every possible password in it. Inverting a password hash would just be an \\(O(1)\\) table lookup, but Eve would then be required to store a table of size \\(\\Omega(|S|)\\).",
        "subquestions": [
            {
                "problem_number": "1a",
                "question": "One early approach to achieving a finer-grained tradeoff between table size and lookup time is hash chains. Just as our cryptographic hash function \\(h\\) is a pseudorandom function mapping \\(S\\) to \\(\\{0,1\\}^{d}\\), it is typically possible to construct a pseudorandom function \\(f\\) mapping \\(\\{0,1\\}^{d}\\) to \\(S\\). In particular, this is possible if \\(S\\) is _efficiently enumerable_. This means that there is an ordering on \\(S\\) such that the \\(i\\)th element of \\(S\\) can be efficiently computed.\n\nIf \\(S\\) is the set of all 10 character alphanumeric passwords, construct a pseudorandom function mapping \\(\\{0,1\\}^{256}\\) to \\(S\\).",
                "answer": "We desire a pseudorandom mapping from \\(\\{0,1\\}^{256}\\) to \\(S\\). First, we note that \\(S\\) is efficiently enumerable. In particular, \\(S\\) follows standard lexicographic order, where each of the 62 possible characters follows the ordering \\(0...9 \\leftarrow A-Z \\leftarrow a-z\\). Then, of the \\(62^{10}\\) possible values in \\(S\\), the \\(i\\)th value is easily attainable by computing the base 62 representation of \\(i-1\\). Now, we want a pseudorandom reduction function, \\(R\\), which maps \\(2^{256}\\) possible values to \\(62^{10}\\). One possible function is simply \\(R(hv) = \\text{sha256}(hv) \\mod 62^{10}\\). In other words, we use a hash function on the item from \\(\\{0,1\\}^{256}\\) to map to another item from \\(\\{0,1\\}^{256}\\) and then take the value mod \\(62^{10}\\). This function is very nearly uniform, since \\(\\frac{2^{256}}{62^{10}} \\geq 10^{59}\\), assuming the hash function is sufficiently random.",
                "custom_id": "request_S14_ps2_0_0"
            },
            {
                "problem_number": "1b",
                "question": "The next idea is that \\(f\\) and \\(h\\) are alternately applied \\(k\\) times on a random password to yield a chain of \\(k\\) passwords and password hashes. Show that if we store a single entry in a lookup table mapping the last hash of this chain to the starting password, then in \\(O(k)\\) time, we can invert any of the hashes which occurred in the chain.",
                "answer": "The general idea is that given some hash \\(hv\\), we can run it through a similar chain process \\(k\\) times. If any of the intermediate hashes match the last hash of some chain in the table, we obtain the corresponding start of the chain \\(s\\). We start with \\(s\\), and walk through the chain again, until we reach some segment \\(\\text{hash}(pl) = hv\\), where \\(pl\\) is our desired plain text. Given that each iteration of hashing or reducing takes \\(O(1)\\) time, and that lookup takes \\(O(1)\\) time, we have an \\(O(k)\\) algorithm for inverting any hash that occurs in some chain.",
                "custom_id": "request_S14_ps2_0_1"
            },
            {
                "problem_number": "1c",
                "question": "A natural next idea is to store multiple (hash, password) pairs in the lookup table, all constructed in the same way. Show that if all the corresponding chains are of length \\(k\\), then we can efficiently invert the hash of any password which occurs in any of the chains. If you create \\(|S|/k\\) chains of length \\(k\\) as described above, do you expect the chains to contain close to \\(|S|\\) distinct passwords?",
                "answer": "We can use the scheme from before, the table can be represented as a hashtable or sorted, to allow for lookup via binary search. Then for every query hash, \\(hv\\), we repeat the process from part B, but lookups will take \\(O(\\frac{|S|}{k})\\) or \\(O(1)\\) depending on whether the table is implemented as a sorted list of entries or a hashtable, respectively. In practice, this is not always true. First, \\(hv\\) might be part of a chain that shares an endpoint with another chain, but is not present in the table. Additionally, chains can merge on collision. A query might need to search through all such chains that share the endpoint before finding the chain that contains \\(hv\\).\n\nOne might guess that each chain may store \\(k\\) unique passwords, and that therefore \\(\\frac{|S|}{k}\\) chains would store \\(|S|\\) distinct passwords. In practice, this is not true. Given \\(\\frac{|S|}{k}\\) chains of length \\(k\\), the number of distinct passwords will be much lower than \\(|S|\\) with high probability. The issue is the presence of collisions. For example, let\u2019s consider the optimistic situation where the first \\(\\frac{|S|}{4k}\\) chains all contained completely unique passwords. In other words, one fourth of the password space has been successfully encoded without collision. Now, we want to lower bound the expected number of lost passwords. Consider the remaining \\(\\frac{3|S|}{4k}\\) chains. For each chain \\(i\\), we analyze the probability that one of the first \\(\\frac{k}{2}\\) elements in chain \\(i\\) collides with some element in the first half of a previous chain. In particular, if some collision occurs in the first half of chain \\(i\\) with an element in the first half of a preexisting chain, then at least \\(\\frac{k}{2}\\) passwords in chain \\(i\\) are lost by merging. It\u2019s easy to see this is a lower bound on the losses, since this case only represents a subset of the cases where passwords are lost.\n\nFinally, the total number of expected passwords lost in the remaining chains will be:\n\n\\[\\sum_{i}^{\\frac{3|S|}{k}}E[\\text{lost passwords in chain $i$}] \\geq \\frac{3|S|}{4k} \\cdot \\frac{k}{2} \\cdot (1 - \\frac{1}{8})^{\\frac{k}{2}}\\]\n\nGiven \\(k \\geq 1000\\), which is highly reasonable, since otherwise the table would need at least \\(8.39 \\cdot 10^{14}\\) entries, the above formula yields that at least \\(\\frac{3|S|}{8}\\) passwords will not be unique due to merges. This follows from \\(\\frac{3|S|}{8} \\geq \\frac{3|S|}{4}\\), since we assumed that we had at least one fourth of all passwords in the table.",
                "custom_id": "request_S14_ps2_0_2"
            },
            {
                "problem_number": "1d",
                "question": "Rainbow tables use a different and independent pseudorandom function fi mapping {0, 1}d to S for each step of the chain. Why does this increase the number of distinct hashes you expect the chains to contain?",
                "answer": "Using a family of pseudorandom functions \\(f_{i}\\), for each step in the chain greatly decreases the probability of merges. In particular, for a merge to occur, the collision must occur on the same step \\(j\\) of the chain. If you have length \\(l\\) chains, then any given collision has roughly a \\(\\frac{1}{l}\\) probability of causing a merge. With sufficiently large \\(l\\) (\\(l\\) should be quite large, otherwise the table's size will be unrealistic) using a family of pseudorandom functions significantly decreases the number of merges, and therefore increases the number of distinct passwords.",
                "custom_id": "request_S14_ps2_0_3"
            },
            {
                "problem_number": "1e",
                "question": "How can Ben Bitdiddle modify his password storage scheme to make it infeasible for a precomputed rainbow table to significantly weaken his users\u2019 passwords?",
                "answer": "One defense against rainbow tables is the use of salts. Instead of storing a passwords as \\(hash(pw)\\), Ben would store it as \\(hash(pw+salt)\\) where salt is a randomly generated string of greater than 48 bits. The salt can be stored in plainview, with the password hashes. The additional defense comes from the fact that Eve would need a rainbow table for each salt in order to obtain the passwords for every password in the database.",
                "custom_id": "request_S14_ps2_0_4"
            }
        ]
    },
    {
        "problem_number": "2",
        "question": "Alice and Bob have taken 6.857, and would like to send confidential messages to each other in a way that meets the IND-CCA definition given there. Bob suggests the following method. Let \\(EncCBC(K,M)\\) denote the process of padding \\(M\\) with a 1 bit and then as many 0 bits as needed to make the message length a multiple of 128 bits, and then using AES in CBC mode to encrypt the result, using a randomly-chosen 128-bit IV. The result is: \\[EncCBC(K,M)=IV,C_{1},C_{2},\\ldots,C_{n}\\ .\\] Let \\(Rev(S)\\) denote the reverse of a sequence \\(S\\). That is, \\(S\\) is parsed as a sequence of 128-bit blocks (the length of \\(S\\) must be a multiple of 128 bits), and these blocks are re-arranged into reverse order. Bob then proposes that he and Alice secretly agree on two AES keys \\(K_{1}\\) and \\(K_{2}\\), and then define the encryption of a message \\(M\\) as \\[E(K_{1},K_{2};M)=EncCBC(K_{2},Rev(EncCBC(K_{1},M)))\\ .\\] The intent here is that the reversal avoids the problem noted in class, that 'ciphertext prefixes decode as prefixes of the message.' Show that this method does _not_ meet the IND-CCA security definition given in class. That is, show how the adversary can 'win' the security game against this method.",
        "subquestions": [
            {
                "problem_number": "2a",
                "question": "Show that this method does _not_ meet the IND-CCA security definition given in class. That is, show how the adversary can 'win' the security game against this method.",
                "answer": "**Theorem:** Bob's method \\(E\\) is _not_ IND-CCA secure. **Proof:** The adversary picks \\(m_{0}=0^{x},m_{1}=1^{x}\\) for large \\(x\\geq 3\\cdot 128\\) in phase I. Then \\(y=E_{K_{1},K_{2}}(m_{d})\\). Let \\(z=y\\) with the first bit flipped. Since \\(z\neq y\\), the adversary is allowed to ask for \\(D_{K_{1},K_{2}}(z)\\) in phase II. This correctly gives the first \\(128\\)-bit block of \\(m_{d}\\), revealing \\(d\\) (zeroes if \\(d=0\\) or ones if \\(d=1\\)). Therefore, the adversary wins the game. Why does this work? Consider the steps of \\(E\\), where \\(m_{d}\\) is divided into \\(n\\)\\(128\\)-bit blocks (\\(n\\geq 3\\)): 1. Start with \\(m_{d}=m_{1},\\ldots,m_{n}\\). 2. \\(\\mathsf{EncCBC}_{K_{1}}(m_{1},\\ldots,m_{n})=IV^{(1)},C_{1}^{(1)},\\ldots,C_{n}^{(1)}\\). 3. \\(\\mathsf{Rev}(IV^{(1)},C_{1}^{(1)},\\ldots,C_{n}^{(1)})=C_{n}^{(1)},\\ldots,C_{1}^{(1)},IV^{(1)}\\). 4. \\(\\mathsf{EncCBC}_{K_{2}}(C_{n}^{(1)},\\ldots,C_{1}^{(1)},IV^{(1)})=IV^{(2)},C_{1}^{(2)},\\ldots,C_{n}^{(2)},C_{n+1}^{(2)}\\). 5. End with \\(IV^{(2)},C_{1}^{(2)},\\ldots,C_{n}^{(2)},C_{n+1}^{(2)}=y\\). Now, consider the steps of \\(D\\), which reverses \\(E\\). 1. Start with \\(y=IV^{(2)},C_{1}^{(2)},\\ldots,C_{n}^{(2)},C_{n+1}^{(2)}\\). 2. \\(\\mathsf{DecCBC}_{K_{2}}(IV^{(2)},C_{1}^{(2)},\\ldots,C_{n}^{(2)},C_{n+1}^{(2)})=C_{n}^{(1)},\\ldots,C_{1}^{(1)},IV^{(1)}\\). 3. \\(\\mathsf{Rev}(C_{n}^{(1)},\\ldots,C_{1}^{(1)},IV^{(1)})=IV^{(1)},C_{1}^{(1)},\\ldots,C_{n}^{(1)}\\). 4. \\(\\mathsf{DecCBC}_{K_{1}}(IV^{(1)},C_{1}^{(1)},\\ldots,C_{n}^{(1)})=m_{1},\\ldots,m_{n}\\). 5. End with \\(m_{1},\\ldots,m_{n}=m_{d}\\). Finally, consider the steps of \\(D\\) when the input is \\(z\\) instead of \\(y\\) (the first bit is flipped). Denote any changed blocks in red. As we observed in Lecture 9, the bit flip only affects the decryption of the current block and the next block, since each decrypted block only depends on \\(C_{i}\\) and \\(C_{i-1}\\) (and only the first block depends on \\(IV\\)). 1. Start with \\(z=IV^{(2)},C_{1}^{(2)},\\ldots,C_{n}^{(2)},C_{n+1}^{(2)}\\). 2. \\(\\mathsf{DecCBC}_{K_{2}}(IV^{(2)},C_{1}^{(2)},\\ldots,C_{n}^{(2)},C_{n+1}^{(2)})=C_{n}^{(1)},\\ldots,C_{1}^{(1)},IV^{(1)}\\). 3. \\(\\mathsf{Rev}(C_{n}^{(1)},\\ldots,C_{1}^{(1)},IV^{(1)})=IV^{(1)},C_{1}^{(1)},\\ldots,C_{n}^{(1)}\\). 4. \\(\\mathsf{DecCBC}_{K_{1}}(IV^{(1)},C_{1}^{(1)},\\ldots,C_{n}^{(1)})=m_{1},\\ldots,m_{n}\\). 5. End with \\(m_{1},\\ldots,m_{n}\\). Therefore, the first block \\(m_{1}\\) of \\(m_{d}\\) is correct, revealing \\(d\\).",
                "custom_id": "request_S14_ps3_0_0"
            }
        ]
    },
    {
        "problem_number": "3",
        "question": "Ben Bitdiddle has designed a new cryptosystem called Kalns, but we suspect it might not be as strong as we would like to be. Therefore we ask your help to break it. In this problem we will be working with a finite field \\(\\mathsf{GF}_{16}\\). The elements of our field are all 4-bit strings. The field addition is computed as xor: \\(\\mathsf{GF}_{16}(x)+\\mathsf{GF}_{16}(y)=\\mathsf{GF}_{16}(x\\oplus y)\\). We provide the two tables describing addition and multiplication laws on the course web page. If you are curious, these tables are obtained by interpreting 4-bit field elements as degree \\(\\leq 4\\) polynomials over \\(\\mathsf{GF}_{2}\\) and performing addition and multiplication modulo the irreducible polynomial \\(x^{4}+x+1\\). However, for the purposes of this problem you do _not_ need to understand how our \\(\\mathsf{GF}_{16}\\) is constructed; the solutions we know assume black-box access to \\(\\mathsf{GF}_{16}\\). We have provided a \\(\\mathsf{GF}_{16}\\) implementation for you. Kalns is a 64-bit block cipher. The secret key consists of three parts: * an invertible 16-by-16 matrix \\(A\\) over \\(\\mathsf{GF}_{16}\\); * a 16-element vector \\(b\\) over \\(\\mathsf{GF}_{16}\\); and * a permutation (bijection) \\(S\\) that maps \\(\\mathsf{GF}_{16}\\) one-to-one and onto \\(\\mathsf{GF}_{16}\\). To encrypt a 64-bit block \\(B\\) we first break it up in sixteen 4-bit chunks and interpret each of them as a \\(\\mathsf{GF}_{16}\\) element. So block \\(B\\) corresponds to length 16 vector \\(x=(x_{0},\\ldots,x_{15})\\) over \\(\\mathsf{GF}_{16}\\). The encryptions consists of the following: \\(y=S(Ax+b)\\), where the permutation \\(S\\) is individually applied to each of 16 elements of \\(v=Ax+b\\). The 16-element vector \\(y\\) is later re-interpreted as 64-bit integer to obtain the encrypted block \\(B^{\\prime}\\).",
        "subquestions": [
            {
                "problem_number": "3a",
                "question": "Ben suspects that his cryptosystem is very secure. After all it has around \\(16^{16^{2}}\\cdot 16^{16}\\cdot 16!\\approx 21132.25\\) possible keys. However, we suspect that there are many equivalent keys. These keys have different values for \\((A,b,S)\\), but produce the same ciphertext for any given plaintext. Is our suspicion well-founded?",
                "answer": "Our suspicion is well founded, which we can see from a very simple analysis. Consider an original key combination \\((A, b, S)\\), where we call \\(Ax+b=v\\). Let us then consider a possible key combination \\((n*A, n*b, S')\\), where \\(n\\) is some number in \\(\\mathsf{GF}_{16}\\). The output of this new key pair will be \\(S^{\\prime}(nAx+nb)=S^{\\prime}(nv)\\). Thanks to the properties of \\(\\mathsf{GF}_{16}\\), we know that \\(n*m\\), where \\(n\\) is a \\(\\mathsf{GF}_{16}\\) value held constant and \\(m\\) is a \\(\\mathsf{GF}_{16}\\) value varied from 0 to 16, return all different values ranging from 0 to 16. (Of course, the case where \\(m = 0\\) maps to 0, but the other cases map more interestingly.) Thus, multiplying \\(v\\) by \\(n\\) can be considered as just an extra permutation, \\(P(v)\\). (This is true if \\(n\\) is nonzero, but we are simply choosing this to be the case.) This means we can just adjust \\(S'\\) to look like \\(S\\) after canceling out this original mapping, i.e \\(S^{\\prime}(x)=S(P^{-1}(x))\\), and we have an equivalent key pair. Thus we have generated several equivalent key pairs. It turns out that, since we have such freedom with \\(S\\), we can actually generate even more equivalent key pairs by basically generating new \\(v\\)'s and adjusting our \\(S\\) accordingly, as shown above. Thus, we know that there will be many equivalent key pairs.",
                "custom_id": "request_S14_ps3_1_0"
            },
            {
                "problem_number": "3b",
                "question": "Describe a chosen-ciphertext attack on Kalns that recovers the unknown key \\((A,b,S)\\) or an equivalent key.",
                "answer": "Let's consider a series of possible inputs and outputs that we could try encrypting/decrypting, and consider the information gleaned from each. If we encrypt the vector \\(x_{0}=[0,0,0,0,...,0]\\), we will get \\(y_{0}=S(b)\\). Additionally, if we encrypt the vectors \\(x_{u}^{i}\\), which are the 16 unit vectors (i.e. the vectors with all 0's except a 1 at position \\(i\\)), we will get back \\(y_{u}^{i}=S(A^{i}+b)\\), where \\(A^{i}\\) is the \\(i\\)'th column of \\(A\\). We now have information about \\(A\\) and \\(b\\), but they are embedded in \\(S\\), the permutation. In order to get information about this, we can decrypt the values \\(y_{v}^{i}=[i,0,0,0,...0]\\). Reversing our algorithm, we can see that \\(x=A^{-1}(S^{-1}(y)-b)\\), which means we will get back \\(x_{v}^{i}=(A^{-1})^{0}(S^{-1}(y_{v}^{i})-b)\\). If we take the first element of these \\(x_{v}^{i}\\), we will get \\((A^{-1})^{0,0}(S^{-1}(i)-b^{0})\\), and if we take the differences \\(d^{i}=x_{v}^{0}-x_{v}^{i}\\), we will get \\((A^{-1})^{0,0}(S^{-1}(0)-S^{-1}(i))\\). Here, we take advantage of the properties of \\(\\mathsf{GF}_{16}\\) to define a new, valid permutation, \\(S^{\\prime}\\) such that \\(S^{\\prime-1}=(A^{-1})^{0,0}S^{-1}\\), such that the values \\(d^{i}\\) are actually differences between the inverse permutation values for 0 and \\(i\\). Defining \\(S'(0) = 0\\), we thus have a valid permutation that we have fully defined, and which we can construct an equivalent key pair using. (Recall from part a that we can do this because our permutation is correct up to a multiplicative constant!). Using this new \\(S'\\), we can decrypt \\(S(b)\\) such that \\(S^{\\prime-1}(S(b))=b^{\\prime}\\), and similarly extract each column of \\(A\\) as a column of a new matrix \\(A'\\). This new key combination \\((A^{\\prime},b^{\\prime},S^{\\prime})\\) is equivalent to the original combination \\((A,b,S)\\). Since we now have an equivalent key set to the original combination, we can freely encrypt and decrypt data as we please, completely compromising the Kalns encryption scheme.",
                "custom_id": "request_S14_ps3_1_1"
            },
            {
                "problem_number": "3c",
                "question": "To demonstrate that your attack works, write an implementation that can break a randomly generated key. We have set up a web server that implements Kalns algorithm at http://6857.scripts.mit.edu/kalns/. Prove that your implementation works by getting your team's name on the list of successful teams. The server is powered by scripts.mit.edu shared hosting infrastructure. Please don't issue denial of service attacks or try to attack their servers.",
                "answer": "We have successfully implemented this algorithm. See MCRBFinalFast on http://6857.scripts.mit.edu/kalns/. Our code follows the exact process detailed in part b. The MITx submission site only allows one uploaded file, so we did not submit our actual code file, but the code we used is reproduced below using the verbatim tag.\n\n```python\nfrom kalns import *\n\ntokenString = remote_query('keygen?team=MCRBFinalFast')\n\ntheToken = tokenString[80:112]\n\nrk = RemoteKalns(theToken)\n\nb = int64_to_GF16_vec(rk.enc(0))\n\nr_unit = []\nfor i in range(16):\n    r_unit.append(int64_to_GF16_vec(rk.enc(2**(4*(15-i)))))\n\nA = []\nfor row in range(16):\n    A.append([])\n    for col in range(16):\n        A[row].append(r_unit[col][row])\n\niTimesAlnv = []\nfor i in range(16):\n    iTimesAlnv.append(int64_to_GF16_vec(rk.dec(i*(2**(4)))))\n\ntopVals = []\nfor i in range(16):\n    topVals.append(iTimesAlnv[i][0])\n\nfor i in range(1):\n    for ii in range(1):\n        AA = []\n        BB = []\n        s = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]\n        sinv = []\n        for iii in range(16):\n            x = topVals[iii]\n            x0 = topVals[0]\n            s[int((GF16(i) - ((x0-x)/GF16(ii+1))).val)] = int(iii)\n\n        for ij in range(16):\n            sinv.append(s.index(ij))\n        for k in range(16):\n            AA.append([])\n            for l in range(16):\n                AA[k].append(GF16(sinv[A[k][l].val]))\n            BB.append(GF16(sinv[b[k].val]))\n\n        for kk in range(16):\n            for ll in range(16):\n                newVar = AA[kk][ll] - BB[kk]\n                AA[kk][ll] = newVar\n\n        print \"s = \" + str(i) + \", Ainv[0][0] = \" + str(ii)\n        print rk.answer(AA, BB, s)\n```",
                "custom_id": "request_S14_ps3_1_2"
            }
        ]
    }
]